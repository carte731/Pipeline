#!/bin/bash

declare -A projectDic=(
    ["windowLength"]=4 #-w
    ["inputFile"]='' #-i
    ["inputLoc"]=''
    ["outputLoc"]='' #-o
    ["filename"]=''
    ["projectName"]='out' #-p
    ["flanks"]=0 #-f
    ["referenceGenome"]='' #-r
    ["OperationalStage"]='vcfTObed'
    ["JOB"]='NO_JOB_NOW'
)

declare -a dirL=('AtoC' 'AtoG' 'AtoT' 'CtoA' 'CtoG' 'CtoT' 'GtoA' 'GtoC' 'GtoT' 'TtoA' 'TtoC' 'TtoG')

starter(){ #grabs the arguments
    DATE=`date +"%m%d%Y-%H%M"`
    local args=("$@")
    if [[ "$#" > 1 ]] && [[ ${args[0],,} != "--help" ]] && [[ ${args[0],,} != "-h" ]]; then
        local frontgate=0
        local indexPos=0
        for i in $@; do
            if [[ "${i,,}" == "-w" ]]; then ##Window expansion size
                local var=${args[${indexPos}+1]}
                if [[ "$var" =~ ^[0-9]+$ ]]; then ##Checks if it's a number, max expansion of 1000.
                    ((projectDic["windowLength"]+="$var"))
                    frontgate=1
                else
                    echo -e "\nPlease enter a valid integer for window expansion size, defaulting to ZERO.\n"
                fi
            elif [[ "${i,,}" == "-i" ]]; then ##Input file which grabs the input file name, location and complete file path 
                local var=${args[${indexPos}+1]}
                if [[ "${var##*.}" == "vcf" ]] && [ -f "$var" ]; then ##Checks if it's VCF and if file exist
                    projectDic["inputFile"]+="$var"
                    projectDic["inputLoc"]+="${var%/*}"
                    local filename=${var%.*} ##removes files extension
                    filename=${filename##*/} ##removes file path
                    projectDic["filename"]+="$filename"
                    frontgate=1
                else
                    echo -e "\nERROR. Incorrect file input. Check file or directory path. (Input (.vcf) only)\nEXITING...\n"
                    exit 1
                fi
            elif [[ "${i,,}" == "-o" ]]; then ##output location info
                local var=${args[${indexPos}+1]}
                if [ -d "$var" ]; then ##Checks if directory exist, if not it will save to input file location
                    if [[ "${var: -1}" == "/" ]]; then
                        projectDic["outputLoc"]+="$var"
                    else
                        projectDic["outputLoc"]+="$var"/
                    fi
                    frontgate=1
                fi
            elif [[ "${i,,}" == "-p" ]]; then ##Project name
                local var=${args[${indexPos}+1]}
                projectDic["projectName"]="$var"
                frontgate=1
            elif [[ "${i,,}" == "-f" ]]; then ##Flank sizes for mutation motif's aln_to_counts func
                local var=${args[${indexPos}+1]}
                frontgate=1
                if [[ "$var" =~ ^[0-2]+$ ]]; then ##Checks if it's a number and if it's between 0 and 2
                    ((projectDic["flanks"]+="$var"))
                else
                    echo -e "\nFlanks have to be between: 0 - 2. Defaulting to 0.\n"
                fi
            elif [[ "${i,,}" == "-r" ]]; then ##Which reference genome needed for FASTA file creation
                local var=${args[${indexPos}+1]}
                referenceAssignment ${var}
                frontgate=1
            elif [[ "${i}" == "-JOB" ]]; then
                local var=${args[${indexPos}+1]}
                projectDic["JOB"]="${var}"
            fi
            ((indexPos+=1))
        done
        if ((${frontgate} <= 0)); then
            echo -e "\nPlease enter valid arguments. None where valid.\n"
        fi
        if [[ ${projectDic["inputFile"]} == '' ]]; then
            echo -e "\nNo input file or working directory specified.\nEXITING...\n"
            exit 1
        fi
        if [[ -z ${projectDic["outputLoc"]} ]] && [[ ${projectDic["inputFile"]} != '' ]]; then
            echo -e "\nNot a valid output location. Re-routing to input file location.\n"
            projectDic["outputLoc"]+=${projectDic["inputLoc"]}
        fi
        if [[ ${projectDic["referenceGenome"]} == "" ]]; then
            referenceAssignment
        fi
        # mkdir "${projectDic["outputLoc"]}"FASTA_SPLIT
        # mkdir "${projectDic["outputLoc"]}"BED_SPLIT
        # echo -e "${projectDic["outputLoc"]}" ###
        if [[ "${projectDic["JOB"]}" != "THIS_IS_A_JOB" ]]; then
            mkdir "${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
            projectDic["outputLoc"]="${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
            mkdir "${projectDic[outputLoc]}"SPLITVCF
            mkdir "${projectDic[outputLoc]}"FASTA_SPLIT
            mkdir "${projectDic[outputLoc]}"BED_SPLIT
        fi
    else
        local helpPrintOut=$'\n\tSNP context\n\tList of commands:\n\t------------------------\n'
        helpPrintOut+=$'\n\t./SNPcontext -i <input> -o <output> -r <reference genome> -w <expansion size> -f <alignment window flank]> -p <project name>\n'
        helpPrintOut+=$'\n\t------------------------\n'
        helpPrintOut+=$'\n\t-i [File input, VCF only]\n\t-o [output location (defaults to input location if not stated)]'
        helpPrintOut+=$'\n\t-r [Reference genome]\n\t-w [window expansion size]\n\t-f [mutation motif window flank]'
        helpPrintOut+=$'\n\t-p [project name]\n'
        echo "$helpPrintOut"
        exit -0
    fi
}

fileLayout(){

        mkdir "${projectDic[outputLoc]}""${dir}"_COUNTS_TABLES
        mkdir "${projectDic[outputLoc]}""${dir}"_COUNTS_TABLES/LOGS
}

referenceAssignment(){
    if [[ ${var,,} == "barley" ]] || [[ ${var,,} == "b" ]]; then ##forced lowercase with ,,
        projectDic["referenceGenome"]+='/home/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
    elif [[ ${var,,} == "soy bean" ]] || [[ ${var,,} == "s" ]] || [[ ${var,,} == "soy" ]]; then
        projectDic["referenceGenome"]+="panfs/roc/groups/9/morrellp/shared/References/Reference_Sequences/Soybean/PhytozomeV11/Gmax/assembly/Gmax_275_v2.0.fa"
    else
        echo -e "\nPlease enter a valid reference genome. Defaulting to Barley reference.\n"
        projectDic["referenceGenome"]+='/home/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
    fi
}

moduleLoader(){ #load modules need for operations

    module load R
    module load python3_ML/3.6.1
    module load bedops_ML/2.4.20
    module load bedtools_ML/2.23.0

}

fileConverter(){
    if [ "${projectDic[OperationalStage]}" == "vcfTObed" ]; then ##Key and new input LOCATION
        local temp="${projectDic[outputLoc]}"SPLITVCF/
        local splitDir=("${temp}"*_split_"${projectDic[filename]}".vcf*)
        for gene in "${splitDir[@]}"; do
            local targetVCF="${gene%.*}"
            targetVCF="${targetVCF##*/}"
            vcf2bed < "${gene}" > "${projectDic["outputLoc"]}"BED_SPLIT/"${targetVCF}".bed ##sort later
        done
        projectDic[OperationalStage]="bedTOfasta"
    # elif [ "${projectDic[OperationalStage]}" == "...." ]; then ##OLD CODE, MOST LIKELY WILL REMOVE
    #     local declare -A aln_out
    #     local declare -a dirL=('AtoC' 'AtoG' 'AtoT' 'CtoA' 'CtoG' 'CtoT' 'GtoA' 'GtoC' 'GtoT' 'TtoA' 'TtoC' 'TtoG')
    #     temp="${projectDic[outputLoc]}"BED_SPLIT/
    #     splitDir=("${temp}"*_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".bed*)
    #     for gDir in ${dirL[@]}; do
    #         comSDir="${gDir}"_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".bed
    #         counter=0
    #         for sp in ${splitDir[@]}; do
    #             if [[ "${splitDir[$counter]##*/}" == "${comSDir}" ]]; then
    #                 bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${projectDic["outputLoc"]}"BED_SPLIT/"${comSDir}" -fo "${projectDic[outputLoc]}"FASTA_SPLIT/"${gDir}"_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta
    #                 aln_out+=( ["${gDir}"]="${projectDic[outputLoc]}"FASTA_SPLIT/"${gDir}"_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta )
    #             fi
    #             ((counter+=1))
    #         done
    #     done
    #     projectDic["OperationalStage"]="alnToCounts"
    #     if [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
    #         mkdir "${projectDic[outputLoc]}"COUNTS_TABLES
    #         for d in "${!aln_out[@]}"; do
    #             aln_to_counts --align_path "${aln_out[$d]}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES --flank_size "${projectDic[flanks]}" --direction "${d}" -F
    #         done
    #         mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
    #         mv "${projectDic[outputLoc]}"COUNTS_TABLES/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
    #         projectDic["OperationalStage"]="DONE..."
    #     fi
    # elif [ "${projectDic[OperationalStage]}" == "bedTOfasta" ]; then
    #         bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${projectDic[outputLoc]}""${projectDic["projectName"]}"_"${projectDic["filename"]}"_new_interval.bed -fo "${projectDic[outputLoc]}""${projectDic["projectName"]}"_"${projectDic[filename]}".fasta    
    #         projectDic["OperationalStage"]="alnToCounts"
    # elif [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
    #     local temp="${projectDic[outputLoc]}"FASTA_SPLIT/
    #     local splitDir=("${temp}"*_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta*)
    #     for gDir in ${dirL[@]}; do
    #         local comSDir="${gDir}"_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta
    #         local counter=0
    #         for sp in ${splitDir[@]}; do
    #             if [[ "${splitDir[$counter]##*/}" == "${comSDir}" ]]; then
    #                 aln_to_counts --align_path "${splitDir[$counter]}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES --flank_size "${projectDic[flanks]}" --direction "${gDir}" -F
    #             fi
    #             ((counter+=1))
    #         done
    #     done
    #     mv "${projectDic[outputLoc]}"COUNTS_TABLES/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
    #     all_counts -c ${projectDic[outputLoc]}COUNTS_TABLES/"*.txt*" -o "${projectDic[outputLoc]}"
    #     projectDic["OperationalStage"]="DONE..." 
    elif [ "${OperationalStage}" == "bedTOfasta" ]; then
        bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${projectDic[outputLoc]}"BED_SPLIT/"${geneDir}"_"${projectDic["filename"]}"_new_interval.bed -fo "${projectDic[outputLoc]}"FASTA_SPLIT/"${geneDir}"_"${projectDic[filename]}".fasta
        OperationalStage="alnToCounts"
        if [ "${OperationalStage}" == "alnToCounts" ]; then
            fastaLoc="${projectDic[outputLoc]}"FASTA_SPLIT/"${geneDir}"_"${projectDic[filename]}".fasta
            wcFile="${geneDir}"_"${projectDic[filename]}".txt
            mkdir "${projectDic[outputLoc]}""${gDir}"_COUNTS_TABLES
            mkdir "${projectDic[outputLoc]}""${gDir}"_COUNTS_TABLES/LOGS
                for gDir in ${dirL[@]}; do
                    aln_to_counts --align_path "${fastaLoc}" --output_path "${projectDic[outputLoc]}""${gDir}"_COUNTS_TABLES --flank_size "${projectDic[flanks]}" --direction "${gDir}" -F
                    mv "${projectDic[outputLoc]}""${gDir}"_COUNTS_TABLES/"${wcFile}" "${projectDic[outputLoc]}""${gDir}"_COUNTS_TABLES/"${gDir}"_"${wcFile}"
                done
            mv "${projectDic[outputLoc]}""${gDir}"_COUNTS_TABLES/*.log* "${projectDic[outputLoc]}""${gDir}"_COUNTS_TABLES/LOGS
            all_counts -c "${projectDic[outputLoc]}""${gDir}"_COUNTS_TABLES/"*.txt*" -o "${projectDic[outputLoc]}""${gDir}"_COUNTS_TABLES/
            projectDic["OperationalStage"]="DONE..."
        fi
    fi
}

pythonBEDScanner(){
    inputFile="${projectDic["inputFile"]}" outputLoc="${projectDic["outputLoc"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" windowLength="${projectDic["windowLength"]}" geneDir="$geneDir" python3.6 - <<END_OF_PYTHON
    
import os
from itertools import chain
# import itertools
import datetime

def bedMapper(interval, outputLoc, projectName, filename, geneDir):
    bedMapper=[]
    masterList=[]
    sub=[] ##FOR BEDMAPPER
    temp=[] ##FOR MASTERLIST
    final=''
    with open(outputLoc + "BED_SPLIT/" + geneDir + "_split_" + filename + ".bed", "rb") as bed_test: ##Change to input variables
        bedmap=bed_test.read()
        for asii in bedmap:
            element = chr(asii)
            if((element != '\t') and (element != '\n')):
                final = final + element
            elif((element == '\t') and (element != '\n')):
                sub.append(final)
                final=''
                sub.append(element)
            if(element == "\n"):
                sub.append(final)
                sub.append(element)
                sub[2] = str(int(sub[2]) - interval)
                sub[4] = str(int(sub[4]) + interval)
                a = sub[2]
                b = sub[4]
                temp.append(int(a))
                temp.append(int(b))
                temp.sort()
                bedMapper.append(sub)
                masterList.append(temp)
                final=''
                sub=[]
                temp=[]
        return(bedMapper, masterList)

def binaryIntersect(expandedList, interval, outputLoc, projectName, filename):
    gateA=True
    gateB=True
    now = datetime.datetime.now()
    results = '\n**********************\nTYPE ONE and TYPE TWO CHECKS FOR: ' + now.strftime("%Y-%m-%d, %H:%M") + '\n----------------------------------------------------\n' ##ADD PROJECT NAME TO THIS
    resultsA = '\n**TYPE ONE: OVERLAPS INTO ORIGINAL SNP**\n------------------------------------\n'
    resultsB = '\n**TYPE TWO: OVERLAPS INTO SNP EXPANSION WINDOWS**\n-------------------------------------\n'
    for i in range(len(expandedList)-1): #Checks for Type One SNP overlaps (ORIGINAL INTERVAL CHECK)
            a=expandedList[i][0] ##A= left side
            b=expandedList[i][1] ##B= right side
            subTA=expandedList[i+1][0]+interval ##TYPE ONE
            subTB=expandedList[i+1][1]-interval ##TYPE ONE
            subMA=expandedList[i+1][0] ##TYPE TWO
            subMB=expandedList[i+1][1] ##TYPE TWO
            binary=[0,0,0,0]
            binaryMB=[0,0,0,0]
            if(a <= subTA):
                binary[0]=1
            if(a <= subTB):
                binary[1]=1
            if(b >= subTA):
                binary[2]=1
            if(b >= subTB):
                binary[3]=1
            if(a <= subMA): ##
                binaryMB[0]=1
            if(a <= subMB):
                binaryMB[1]=1
            if(b >= subMA):
                binaryMB[2]=1
            if(b >= subMB):
                binaryMB[3]=1
            if((binary != [1,1,0,0]) and (binary != [0,0,1,1])):
                gateA=False
                if(binary == [0,1,1,0]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subTA) + "-" + str(subTB) + '.'
                elif(binary == [1,1,1,1]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subTA) + "-" + str(subTB) + '.'
                elif((binary == [1,1,1,0]) or (binary == [0,1,1,1])):
                    if(binary == [1,1,1,0]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the right, between " + str(b) + " and " + str(subTA) + '.'
                    elif(binary == [0,1,1,1]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the left, between " + str(a) + " and " + str(subTB) + '.' 
            if(interval > 4):
                if((binaryMB != [1,1,0,0]) and (binaryMB != [0,0,1,1])):
                    gateB=False
                    if(binaryMB == [0,1,1,0]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subMA) + "-" + str(subMB) + '.'
                    elif(binaryMB == [1,1,1,1]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subMA) + "-" + str(subMB) + '.'
                    elif((binaryMB == [1,1,1,0]) or (binaryMB == [0,1,1,1])):
                        if(binaryMB == [1,1,1,0]):
                            resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the right, between " + str(b) + " and " + str(subMA) + '.'
                        elif(binaryMB == [0,1,1,1]):
                            resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the left, between " + str(a) + " and " + str(subMB) + '.' 
    if(gateA):
        print("\nNo Type ONE window overlaps detected.\n")
        resultsA+="\nNo Type ONE window overlaps detected.\n"
    else:
        print("\nTYPE ONE OVERLAPS DETECTED.")
    if(gateB):
        print("\nNo Type TWO window overlaps detected.\n")
        resultsB+="\nNo Type TWO window overlaps detected.\n"
    else:
        print("\nTYPE TWO OVERLAPS DETECTED.")
    results += resultsA + "\n" + resultsB + "\n"
    results += "\nEND OF INTERVAL CHECKS.\nXXXXXXXXXXXXXXXXXXXXXX\n"
    if((gateA == True) and (gateB == True)):
        print("\nNO overlaps dectected. Results saved to 'WindowOverlap.txt' in your output directory.\n")
    else:
        print("\nTYPE ONE AND/OR TYPE TWO OVERLAPS DETECTED. Check 'WindowOverlap.txt' in your output directory for saved results.\n")
    with open(outputLoc + projectName + "_" + "WindowOverlap.txt", 'a+') as window:
        window.write(results)

# def fileSaverTwo(bedMapp, outputLoc, filename, projectName, dirC):
#     if(dirC == None):
#         output="".join(chain.from_iterable(bedMapp))
#         with open(outputLoc + "/" + geneDir + "_" + filename + "_new_interval.bed", "w") as newBed: ##Change to input variables
#             newBed.write(output)
#     else:
#         output="".join(chain.from_iterable(bedMapp)) ##
#         with open(outputLoc + "/BED_SPLIT/" + dirC + "_" + "split" + "_" + projectName + "_" + filename + ".bed", "w") as splitBed: ##Change to input variables
#             splitBed.write(output)

# def bedSpliter(bedMapp, outputLoc, filename, projectName):
#     directions=["AtoC","AtoG","AtoT","CtoA","CtoG","CtoT","GtoA","GtoC","GtoT","TtoA","TtoC","TtoG"]
#     for j in directions:
#         masterList=[]
#         for i in range(len(bedMapp)):
#             dirC=bedMapp[i][10] + "to" + bedMapp[i][12]
#             if(dirC == j):
#                 masterList.append(bedMapp[i])
#         if(len(masterList) > 0):
#             fileSaver(masterList, outputLoc, filename, projectName, j)  

def fileSaver(bedMapp, outputLoc, filename, projectName, geneDir):
        output="".join(chain.from_iterable(bedMapp))
        with open(outputLoc + "BED_SPLIT/" + geneDir + "_" + filename + "_new_interval.bed", "w") as newBed: ##Change to input variables
            newBed.write(output)
        # os.rename(outputLoc + "/" + projectName + "_" + filename + ".bed", outputLoc + "/" + projectName + "_" + filename + "_new_interval.bed")
        
def bashInputs():
    outputLoc=str(os.environ['outputLoc'])
    filename=str(os.environ['filename'])
    windowLength=int(os.environ['windowLength'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    geneDir=str(os.environ['geneDir'])
    return(outputLoc, filename, windowLength, inputFile, projectName, geneDir)

def main():
    outputLoc, filename, interval, inputFile, projectName, geneDir=bashInputs()
    bedmap, masterList=bedMapper(interval, outputLoc, projectName, filename, geneDir)
    binaryIntersect(masterList, interval, outputLoc, projectName, filename)
    fileSaver(bedmap, outputLoc, filename, projectName, geneDir)
main()

END_OF_PYTHON

}

jobCreator(){
    echo -e "Enter email for PBS job updates: "
    read userEmail
    email="${userEmail}" inputFile="${projectDic["inputFile"]}" outputLoc="${projectDic["outputLoc"]}" projectName="${projectDic["projectName"]}" windowLength="${projectDic["windowLength"]}" flanks="${projectDic["flanks"]}" referenceGenome="${projectDic["referenceGenome"]}" python3.6 - <<JOB_CREATED

import os

def jobScript(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc):
    job="#!/usr/bin/env bash\n\n#PBS -l mem=22gb,nodes=1:ppn=16,walltime=24:00:00\n#PBS -m abe\n#PBS -M " + email + "\n"
    job+="#PBS -N " + projectName + "_" + "SNP-Context" + "\n#PBS -q lab\nset -e\nset -o pipefail\n\n"
    job+="module load snpContext/1.0.0\n\n"
    job+="snpcontext "
    job+= "-i " + inputFile + " "
    job+= "-o " + outputLoc + " "
    job+= "-w " + windowLength + " "
    job+= "-f " + flanks + " "
    job+= "-p " + projectName + " "
    job+= "-r " + referenceGenome + " "
    job+= "-JOB THIS_IS_A_JOB"

    with open(outputLoc + projectName + ".job", "w") as jobScript:
        jobScript.write(job)

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    email=str(os.environ['email'])
    flanks=str(os.environ['flanks'])
    referenceGenome=str(os.environ['referenceGenome'])
    windowLength=str(os.environ['windowLength'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    return(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc)

def main():
    projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc = bashImport()
    jobScript(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc)

main()
    
JOB_CREATED

echo -e "\njob submited.\nEXITING...\n"
qsub "${projectDic["outputLoc"]}""${projectDic["projectName"]}".job
exit 0

}

vcfSplit(){
    inputFile="${projectDic["inputFile"]}" outputLoc="${projectDic["outputLoc"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" python3.6 - <<VCF_SPLIT_END

import os

def vcfSegments(inputFile):
    geneDir={

        'AtoC':[],
        'AtoG':[],
        'AtoT':[],
        'CtoA':[],
        'CtoG':[],
        'CtoT':[],
        'GtoA':[],
        'GtoC':[],
        'GtoT':[],
        'TtoA':[],
        'TtoC':[],
        'TtoG':[],
        'rejected':[],

    }
    
    with open(inputFile, "rb") as raw:
        commentGate=False
        test=raw.read()
        sub=[]
        header=''
        results=''
        for ele in test:
            element=chr(ele)
            if(element == "#"):
                commentGate=True
            if((commentGate == False)):
                if((element != '\t') and (element != '\n')):
                    results = results + element
                elif((element == '\t') and (element != '\n')):
                    sub.append(results)
                    results=''
                    sub.append(element)
                if(element == "\n"):
                    results = results + element
                    sub.append(results)
                    gene= str(sub[6]) + "to" + str(sub[8])
                    if gene in geneDir:
                        geneDir[gene]+=sub
                        results=''
                        sub=[]
                    else:
                        geneDir['rejected']+=sub
                        results=''
                        sub=[]
            else:
                header+=element
                if(element == "\n"):
                    commentGate=False
    return(header, geneDir)

def vcfSpliter(header, geneDir, outputLoc, filename):
    for key in geneDir:
        output=''
        if(geneDir[key] != []):
            if(key != "rejected"):
                with open(outputLoc + "SPLITVCF/" + key + "_split_" + filename + ".vcf","w") as vcfOut:
                    output+=header
                    output+="".join(geneDir[key])
                    vcfOut.write(output)
            else:
                with open(outputLoc + "REJECTEDVCFs_" + filename + ".vcf","w") as vcfOut:
                    output+=header
                    output+="".join(geneDir[key])
                    vcfOut.write(output)

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    inputFile=str(os.environ['inputFile'])
    filename=str(os.environ['filename'])
    projectName=str(os.environ['projectName'])
    return(projectName, inputFile, outputLoc, filename)

def main():
    projectName, inputFile, outputLoc, filename=bashImport()
    header, geneDir=vcfSegments(inputFile)
    vcfSpliter(header, geneDir, outputLoc, filename)

main()

VCF_SPLIT_END

}

# mainTop(){

# }

main(){
    moduleLoader ##LOADS CORRECT MODULES    
    starter "$@" ##ASSIGNS INPUTS TO HASHMAP
    # if [[ "${projectDic["JOB"]}" != "THIS_IS_A_JOB" ]]; then
    #     inputSize=$( stat -c%s "${projectDic["inputFile"]}")
    #     if (( "${inputSize}" >= 110000000 )); then
    #         echo -e "\n(.VCF) over 100Mb, generating job script and submitting operations to MSI."
    #         jobCreator
    #     fi
    # fi
    vcfSplit
    # for geneDir in "${dirL}"; do
    # local dirInput="${projectDic[outputLoc]}"SPLITVCF/"${geneDir}"_split_"${projectDic[filename]}".vcf
    # local subFileName="${geneDir}"_split_"${projectDic[filename]}"
    fileConverter "$subFileName" "$geneDir" "$dirInput" "$OperationalStage" ##MAKES BED FILE
    local temp="${projectDic[outputLoc]}"BED_SPLIT/
    local splitDir=("${temp}"*_split_"${projectDic[filename]}".bed*)
    for gene in "${splitDir[@]}"; do
        local geneDir="${gene%.*}"
        geneDir="${geneDir##*/}"
        geneDir=${geneDir:0:4} ##BASH IS BASE 1
        echo -e "${geneDir}"
        # pythonBEDScanner "$geneDir" ##EXPANDS BED FILE WINDOWS AND CHECKS FOR OVER LAP
    done
    # fileConverter "$subFileName" "$geneDir" "$dirInput" "$OperationalStage" ##CREATES FASTA FILE
        # fastaSpliter ##COPIES MASTER FASTA FILE 12 TIMES FOR ALN_TO_COUNTS
        # fileConverter ##ALN_TO_COUNTS TABLES WHICH ARE FED INTO ALL_COUNTS
        ##DONE...
        
}

main "$@"