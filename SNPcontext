#!/bin/bash

declare -A projectDic=(
    ["windowLength"]=0 #-w
    ["inputFile"]='' #-i
    ["inputLoc"]=''
    ["outputLoc"]='' #-o
    ["filename"]=''
    ["projectName"]='out' #-p
    ["flanks"]=0 #-f
    ["referenceGenome"]='' #-r
    ["OperationalStage"]='vcfTObed'
)

starter(){ #grabs the arguments
    DATE=`date +"%m%d%Y-%k%M"`
    local args=("$@")
    if [[ "$#" > 1 ]] && [[ ${args[0],,} != "--help" ]] && [[ ${args[0],,} != "-h" ]]; then
        local frontgate=0
        local indexPos=0
        for i in $@; do
            if [[ "${i,,}" == "-w" ]]; then ##Window expansion size
                local var=${args[${indexPos}+1]}
                if [[ "$var" =~ ^[0-9]+$ ]]; then ##Checks if it's a number, max expansion of 1000.
                    ((projectDic["windowLength"]+="$var"))
                    frontgate=1
                else
                    echo -e "\nPlease enter a valid integer for window expansion size, defaulting to ZERO.\n"
                fi
            elif [[ "${i,,}" == "-i" ]]; then ##Input file which grabs the input file name, location and complete file path 
                local var=${args[${indexPos}+1]}
                if [[ "${var##*.}" == "vcf" ]] && [ -f "$var" ]; then ##Checks if it's VCF and if file exist
                    projectDic["inputFile"]+="$var"
                    projectDic["inputLoc"]+="${var%/*}"
                    local filename=${var%.*}
                    filename=${filename##*/}
                    projectDic["filename"]+="$filename"
                    frontgate=1
                else
                    echo -e "\nERROR. Incorrect file input. Check file or directory path. (Input (.vcf) only)\nEXITING...\n"
                    exit 1
                fi
            elif [[ "${i,,}" == "-o" ]]; then ##output location info
                local var=${args[${indexPos}+1]}
                if [ -d "$var" ]; then ##Checks if directory exist, if not it will save to input file location
                    if [[ "${var: -1}" == "/" ]]; then
                        projectDic["outputLoc"]+="$var"
                    else
                        projectDic["outputLoc"]+="$var"/
                    fi
                    frontgate=1
                fi
            elif [[ "${i,,}" == "-p" ]]; then ##Project name
                local var=${args[${indexPos}+1]}
                projectDic["projectName"]="$var"
                frontgate=1
            elif [[ "${i,,}" == "-f" ]]; then ##Flank sizes for mutation motif's aln_to_counts func
                local var=${args[${indexPos}+1]}
                frontgate=1
                if [[ "$var" =~ ^[0-2]+$ ]]; then ##Checks if it's a number and if it's between 0 and 2
                    ((projectDic["flanks"]+="$var"))
                else
                    echo -e "\nFlanks have to be between: 0 - 2. Defaulting to 0.\n"
                fi
            elif [[ "${i,,}" == "-r" ]]; then ##Which reference genome needed for FASTA file creation
                local var=${args[${indexPos}+1]}
                referenceAssignment ${var}
                frontgate=1
            fi
            ((indexPos+=1))
        done
        if ((${frontgate} <= 0)); then
            echo -e "\nPlease enter valid arguments. None where valid.\n"
        fi
        if [[ ${projectDic["inputFile"]} == '' ]]; then
            echo -e "\nNo input file or working directory specified.\nEXITING...\n"
            exit 1
        fi
        if [[ -z ${projectDic["outputLoc"]} ]] && [[ ${projectDic["inputFile"]} != '' ]]; then
            echo -e "\nNot a valid output location. Re-routing to input file location.\n"
            projectDic["outputLoc"]+=${projectDic["inputLoc"]}
        fi
        if [[ ${projectDic["referenceGenome"]} == "" ]]; then
            referenceAssignment
        fi
        mkdir "${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
        projectDic["outputLoc"]="${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
        mkdir "${projectDic["outputLoc"]}"FASTA_SPLIT
        mkdir "${projectDic["outputLoc"]}"BED_SPLIT
    else
        local helpPrintOut=$'\n\tSNP context\n\tList of commands:\n\t------------------------\n'
        helpPrintOut+=$'\n\t./SNPcontext -i <input> -o <output> -r <reference genome> -w <expansion size> -f <alignment window flank]> -p <project name>\n'
        helpPrintOut+=$'\n\t------------------------\n'
        helpPrintOut+=$'\n\t-i [File input, VCF only]\n\t-o [output location (defaults to input location if not stated)]'
        helpPrintOut+=$'\n\t-r [Reference genome]\n\t-w [window expansion size]\n\t-f [mutation motif window flank]'
        helpPrintOut+=$'\n\t-p [project name]\n'
        echo "$helpPrintOut"
        exit -0
    fi
}

referenceAssignment(){
    if [[ ${var,,} == "barley" ]] || [[ ${var,,} == "b" ]]; then ##forced lowercase with ,,
        projectDic["referenceGenome"]+='/home/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
    elif [[ ${var,,} == "soy bean" ]] || [[ ${var,,} == "s" ]] || [[ ${var,,} == "soy" ]]; then
        projectDic["referenceGenome"]+="soy/temp/path/to/reference/"
    else
        echo -e "\nPlease enter a valid reference genome. Defaulting to Barley reference.\n"
        projectDic["referenceGenome"]+='/home/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
    fi
}

moduleLoader(){ #load modules need for operations

    module load R
    # module load gatk_ML/3.8.0
    # module load vcftools_ML/0.1.14
    module load python3_ML/3.6.1
    module load bedops_ML/2.4.20
    module load bedtools_ML/2.23.0

}

fileConverter(){
    if [ "${projectDic[OperationalStage]}" == "vcfTObed" ]; then
        vcf2bed < "${projectDic["inputFile"]}" > "${projectDic["outputLoc"]}"/"${projectDic["projectName"]}"_"${projectDic["filename"]}".bed
        projectDic["OperationalStage"]="bedTOfasta"
    elif [ "${projectDic[OperationalStage]}" == "...." ]; then
        declare -A aln_out
        declare -a dirL=('AtoC' 'AtoG' 'AtoT' 'CtoA' 'CtoG' 'CtoT' 'GtoA' 'GtoC' 'GtoT' 'TtoA' 'TtoC' 'TtoG')
        temp="${projectDic[outputLoc]}"BED_SPLIT/
        splitDir=("${temp}"*_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".bed*)
        for gDir in ${dirL[@]}; do
            comSDir="${gDir}"_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".bed
            counter=0
            for sp in ${splitDir[@]}; do
                if [[ "${splitDir[$counter]##*/}" == "${comSDir}" ]]; then
                    bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${projectDic["outputLoc"]}"BED_SPLIT/"${comSDir}" -fo "${projectDic[outputLoc]}"FASTA_SPLIT/"${gDir}"_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta
                    aln_out+=( ["${gDir}"]="${projectDic[outputLoc]}"FASTA_SPLIT/"${gDir}"_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta )
                fi
                ((counter+=1))
            done
        done
        projectDic["OperationalStage"]="alnToCounts"
        if [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES
            for d in "${!aln_out[@]}"; do
                aln_to_counts --align_path "${aln_out[$d]}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES --flank_size "${projectDic[flanks]}" --direction "${d}" -F
            done
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
            mv "${projectDic[outputLoc]}"COUNTS_TABLES/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
            projectDic["OperationalStage"]="DONE..."
        fi
    elif [ "${projectDic[OperationalStage]}" == "bedTOfasta" ]; then
        declare -A aln_out
        declare -a dirL=('AtoC' 'AtoG' 'AtoT' 'CtoA' 'CtoG' 'CtoT' 'GtoA' 'GtoC' 'GtoT' 'TtoA' 'TtoC' 'TtoG')
        temp="${projectDic[outputLoc]}"BED_SPLIT/
        splitDir=("${temp}"*_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".bed*)
        for gDir in ${dirL[@]}; do
            comSDir="${gDir}"_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".bed
            counter=0
            for sp in ${splitDir[@]}; do
                if [[ "${splitDir[$counter]##*/}" == "${comSDir}" ]]; then
                    bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${projectDic["outputLoc"]}"BED_SPLIT/"${comSDir}" -fo "${projectDic[outputLoc]}"FASTA_SPLIT/"${gDir}"_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta
                    aln_out+=( ["${gDir}"]="${projectDic[outputLoc]}"BED_SPLIT/"${gDir}"_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta )
                fi
                ((counter+=1))
            done
        done
        projectDic["OperationalStage"]="alnToCounts"
        if [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES
            for d in "${!aln_out[@]}"; do
                aln_to_counts --align_path "${aln_out[$d]}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES --flank_size "${projectDic[flanks]}" --direction "${d}" -F
            done
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
            mv "${projectDic[outputLoc]}"COUNTS_TABLES/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
            all_counts -c "${projectDic[outputLoc]}COUNTS_TABLES/*.txt*" -o "${projectDic[outputLoc]}"
            projectDic["OperationalStage"]="DONE..."
        fi
         
    fi
}

pythonBEDScanner(){
    inputFile="${projectDic["inputFile"]}" outputLoc="${projectDic["outputLoc"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" windowLength="${projectDic["windowLength"]}" python3.6 - <<END_OF_PYTHON
    
import os
from itertools import chain
# import itertools
import datetime

def bedMapper(filename, outputLoc, projectName):
    bedMap=[]
    with open(outputLoc + "/" + projectName + "_" + filename + ".bed", "r") as bed_test: ##Change to input variables
        for i in bed_test:
            sub=[]
            final=''
            for u in i:
                if((u != '\t') and (u != "\n")):
                    final = final + str(u)
                else:
                    sub.append(final)
                    final=''
                    sub.append(u)
            bedMap.append(sub)
    return(bedMap)

def intervalLister(bedMap):
    masterList=[]
    for i in range(len(bedMap)):
        temp=[]
        temp.append(int(bedMap[i][4]))
        temp.append(int(bedMap[i][2]))
        temp.sort()
        masterList.append(temp)
    return(masterList)

def intervalExpander(bedMap, interval):
    masterList=intervalLister(bedMap)
    if(interval > 0):
        for i in range(len(bedMap)):
            if((bedMap[i][2]) and (bedMap[i][4])):
                try:
                    if((type(int(bedMap[i][2])) == int) and (type(int(bedMap[i][4])) == int)):
                        bedMap[i][2] = str(int(bedMap[i][2]) - interval)
                        bedMap[i][4] = str(int(bedMap[i][4]) + interval)
                except:
                    print("\nPython interval expanson error on line: " + bedMap.index(i) + ". Adding error notation to error logs")
                    #Add stuff for logging error to text file
    expandedList=intervalLister(bedMap)
    return(bedMap, masterList, expandedList)

def fastaSpliter(bedMapp, outputLoc, filename, projectName):
    directions=["AtoC","AtoG","AtoT","CtoA","CtoG","CtoT","GtoA","GtoC","GtoT","TtoA","TtoC","TtoG"]
    for j in directions:
        masterList=[]
        for i in range(len(bedMapp)):
            dirC=bedMapp[i][10] + "to" + bedMapp[i][12]
            if(dirC == j):
                masterList.append(bedMapp[i])
        if(len(masterList) > 0):
            fileSaver(masterList, outputLoc, filename, projectName, j)

def bedSpliter(bedMapp, outputLoc, filename, projectName):
    directions=["AtoC","AtoG","AtoT","CtoA","CtoG","CtoT","GtoA","GtoC","GtoT","TtoA","TtoC","TtoG"]
    for j in directions:
        if(masterList != None):
            fileSaver(bedMapp, outputLoc, filename, projectName, j)            

def fileSaver(bedMapp, outputLoc, filename, projectName, dirC):
    if(dirC == None):
        output="".join(chain.from_iterable(bedMapp))
        with open(outputLoc + "/" + projectName + "_" + filename + "_new_interval.bed", "w") as newBed: ##Change to input variables
            newBed.write(output)
    else:
        output="".join(chain.from_iterable(bedMapp)) ##
        with open(outputLoc + "/BED_SPLIT/" + dirC + "_" + "split" + "_" + projectName + "_" + filename + ".bed", "w") as splitBed: ##Change to input variables
            splitBed.write(output)

def typeOneTwo(expandedList, inputList, interval, outputLoc, projectName):
    now = datetime.datetime.now()
    gateOne=True
    gateTwo=True
    typeOT = "ONE"
    results = '\n**********************\nTYPE ONE and TYPE TWO CHECKS FOR: ' + now.strftime("%Y-%m-%d, %H:%M") + '\n----------------------------------------------------\n' ##ADD PROJECT NAME TO THIS    
    if(typeOT == "ONE"):
        results += '\n**Type One: overlap into SNP\n-------------------------------\n'
        for i in range(len(expandedList)): #Checks for Type One SNP overlaps (ORIGINAL INTERVAL CHECK)
            a=expandedList[i][0]
            b=expandedList[i][1]
            if(interval > 0):
                comparisonA=a+interval
                comparisonB=b-interval
            else:
                comparisonA=a
                comparisonB=b
            for j in range(len(inputList)):
                subMA=inputList[j][0]
                subMB=inputList[j][1]
                if((comparisonA != subMA) and (comparisonB != subMB)): ##Add id() check
                    if(i != j):
                        gateOne, tempResults=binaryIntersect(typeOT, a, b, subMA, subMB, gateOne)
                        results+=tempResults
        typeOT="TWO"
        if(gateOne):
            results+="\nNo Type " + typeOT + " window overlaps detected.\n"
    if((typeOT == "TWO") and (interval > 0)): #Checks for Type Two window overlaps (EXTENDED INTERVAL CHECK)
        results += '\n\n**Type Two: overlap into Windows\n-------------------------------\n'
        for i in range(len(expandedList)):
            a2=expandedList[i][0]
            b2=expandedList[i][1]
            for j in range(i+1, len(expandedList)):
                subEA=expandedList[j][0]
                subEB=expandedList[j][1]
                gateTwo, tempResults=binaryIntersect(typeOT, a2, b2, subEA, subEB, gateTwo)
                results+=tempResults
    if(gateTwo):
        results+="\nNo Type " + typeOT + " window overlaps detected.\n"
    results += "\n"
    results += "\nEND OF INTERVAL CHECKS.\nXXXXXXXXXXXXXXXXXXXXXX\n"
    if((gateOne == True) and (gateTwo == True)):
        print("\nNO overlaps dectected. Results saved to 'WindowOverlap.txt' in your output directory.\n")
    else:
        print("\nTYPE ONE AND/OR TYPE TWO OVERLAPS DETECTED. Check 'WindowOverlap.txt' in your output directory for saved results.\n")
    with open(outputLoc + "/" + projectName + "_" + "WindowOverlap.txt", 'a+') as window:
        window.write(results)

def binaryIntersect(typeOT, a, b, subTA, subTB, gate):
    resultsBI=''
    binary=[0,0,0,0]
    if(a <= subTA):
        binary[0]=1 
    if(a <= subTB):
        binary[1]=1
    if(b >= subTA):
        binary[2]=1
    if(b >= subTB):
        binary[3]=1
    if((binary != [1,1,0,0]) and (binary != [0,0,1,1])):
        gate=False
        if(binary == [0,1,1,0]):
            resultsBI+="\n--TYPE " + typeOT + "at :" + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subTA) + "-" + str(subTB)
        elif(binary == [1,1,1,1]):
            resultsBI+="\n--TYPE " + typeOT + " at: " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subTA) + "-" + str(subTB)
        elif((binary == [1,1,1,0]) or (binary == [0,1,1,1])):
            if(binary == [1,1,1,0]):
                resultsBI+="\n--TYPE " + typeOT + " at: " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the right, between " + str(b) + " and " + str(subTA)
            elif(binary == [0,1,1,1]):
                resultsBI+="\n--TYPE " + typeOT + " at: " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the left, between " + str(a) + " and " + str(subTB)
    return(gate, resultsBI)
        
def bashInputs():
    outputLoc=str(os.environ['outputLoc'])
    filename=str(os.environ['filename'])
    windowLength=int(os.environ['windowLength'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    return(outputLoc, filename, windowLength, inputFile, projectName)

def main():
    outputLoc, filename, interval, inputFile, projectName=bashInputs()
    bedMap=bedMapper(filename, outputLoc, projectName)
    bedMap, masterList, expandedList=intervalExpander(bedMap, interval)
    fileSaver(bedMap, outputLoc, filename, projectName, None)
    typeOneTwo(expandedList, masterList, interval, outputLoc, projectName)
    bedSpliter(bedMap, outputLoc, filename, projectName)
    # fastaSpliter(bedMap, outputLoc, filename, projectName)

main()

END_OF_PYTHON

}

mainOne(){
    moduleLoader
    starter "$@"
    fileConverter
    pythonBEDScanner
    fileConverter
}

mainOne "$@"