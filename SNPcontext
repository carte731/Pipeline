#!/bin/bash

#    Corey Carter, St. Paul, MN - 09 January 2018
#    This bash script is designed to pull contextual sequence flanking a SNP (variants) from a reference genome.
#    The window size for contextual sequence can be user specificed.
#    The program checks for the presence of more than one variant within user specified windows.

#    SNP_CONTEXT Version: 2.0.0

set -eE
trap "echo -e There has been an error on $LINEON, please check SNP Context error log for detailed traceback\n" ERR
exec 2>>~/SNP_CONTEXT_ERROR_LOG.txt

#     A bash dictionary for input parameters

declare -A projectDic=(
    ["email"]='' #-em
    ["windowLength"]=1 #-w
    ["inputFile"]='' #-i
    ["inputLoc"]=''
    ["outputLoc"]='' #-o
    ["filename"]=''
    ["projectName"]='out' #-p
    ["flanks"]=0 #-f
    ["referenceGenome"]='' #-r
    ["OperationalStage"]='vcfTObed'
    ["nMax"]=25 ##-n
    ["TempLoc"]=''
    ["tempOut"]=''
    ["allData"]='false' #-ad
    ["msi"]='true' #-msi
    ["s3"]=0 #-s3
    ["dropbox"]='false' #-dpb
    ["dropboxAuth"]='' #-dpba
    ["github"]='false' #-gh
    ["gitUser"]='' #-ghu
    ["gitPass"]='' #-ghp
    ["owner"]='' #-gho
    ["Myrepository"]='' #-ghr
    ["JOB"]='NO_JOB_NOW'
    
)

#     A bash list of all possible nucleotide state transitions
declare -a dirL=('AtoC' 'AtoG' 'AtoT' 'CtoA' 'CtoG' 'CtoT' 'GtoA' 'GtoC' 'GtoT' 'TtoA' 'TtoC' 'TtoG')

declare -a active=()

help_display(){ ## UPDATE TO INCLUDE ALL CMDS AND MENTION THE CONFIG FILE IS THE PREFERED WAY OF OPERATING
    local helpPrintOut=$'\n\tSNP context\n\tList of commands:\n\t------------------------\n'
    helpPrintOut+=$'\n\tSNPcontext -i <input VCF> -o <output> -r <reference genome> -w <expansion size> -f <flank size> -p <project name> -n <acceptable Indel %> -ad <saved all data>\n'
    helpPrintOut+=$'\n\t------------------------\n'
    helpPrintOut+=$'\n\t**Input arguments can be in ANY order.**\n'
    helpPrintOut+=$'\n\t-i [(complete path to VCF file) (the VCF input file)]\n\t-o [(complete path to location) (The output location, if not entered it will default to the same location as your input file.)]'
    helpPrintOut+=$'\n\t-r [(barley or b, soy bean or s )(Selects the reference genome, defaults to Barley if not specified.)]\n\t-w [(Expansion window size)(The expandable window size around the SNP location, 8 on both ends is the deafult.)]'
    helpPrintOut+=$'\n\t-p [project name]\n\t-n [max percentage of indels allowed in fasta files]'
    helpPrintOut+=$'\n\t-a [(true/false) Do you want all temp files (vcf,bed and fasta) to be saved in your output directory]'
    helpPrintOut+=$'\n\t-f [(number between 0 and 2) (flank size for aln_to_counts)]'
    helpPrintOut+=$'\n\t-n [(number)(The percentage of accepted indels in the FASTA file)]'
    helpPrintOut+=$'\n\t-ad [(true or false) (Which stands for “all data”, this allows you to keep all intermediate files (split VCFs, BED, new interval BEDs, FASTA files)\n\t    that are normally deleted after processing. Defaults to false, which deletes intermedidate files.)]\n'
    echo "$helpPrintOut"
    exit -0
}

config_check(){
    local args=($@)
    if (( "$#" >= 1 )); then
        if (( "$#" == 1 )); then
            if [[ ${args[0],,} == "--help" ]] || [[ ${args[0],,} == "-h" ]]; then
                help_display
            elif [[ -f "${args[0]}" ]] || [[ ! -z "${args[0]}" ]]; then
                local var=${args##*.} ## Grabs only the extension
                if [[ ${var,,} == "config" ]]; then ## Checks if it's a .config file
                    isCmd="false"
                    source "${args[0]}"
                    declare -a startList=(
                        ${window_length}
                        ${input_file} # Declares unset variables (NULL), uses -v to check if NULL
                        ${output_location}
                        ${project_name}
                        ${flanks}
                        ${referenceGenome}
                        ${indel_max_amount}
                        ${save_all_data}
                        ${save_S3}
                        ${s3_login}
                        ${s3_password}
                        ${input_email}
                    )
                    starter ${startList}
                else   
                    echo -e "Invalid '.Config' file extension. Exiting..."
                    exit 1
                fi
            else   
                echo -e "Invalid single entry, either enter config file with correct path or --help/-h. Exiting..."
                exit 1
            fi
        elif (( "$#" > 1 )); then
            isCmd="true"
            startList=("$@")
            starter ${startList}
        else 
            echo -e "Invalid entries. Exiting..."
            exit 1
        fi
    else
        help_display
    fi
}

#     Takes user arguments from command line and assigns values to dictionary keys in 'projectDic'
starter(){ #grabs the arguments
    local frontgate=0
    local indexPos=0
    for i in ${startList[@]}; do
        if [[ "${isCmd}" == "true" ]] && [[ ${#startList[@]} != ${indexPos} ]]; then
            local var="${startList[${indexPos}+1]}"
        elif [[ "${isCmd}" == "false" ]]; then
            local var="${i}"
        fi
        # if [[ "${i,,}" == "-w" ]] || [[ ! -v ${window_length} ]]; then ##Window expansion size
        if [[ "${i,,}" == "-em" ]] || [[ ${input_email} == $i ]]; then
            projectDic["email"]="${var}"
            unset input_email
        elif [[ "${i,,}" == "-w" ]] || [[ ${window_length} == $i ]]; then ##Window expansion size
            if [[ "$var" =~ ^[0-9]$ ]] && (( "$var" >= 0 )); then ##Checks if it's a number, max expansion of 10
                if (( "$var" > 10 )); then ##Changed from 2 to 1
                    echo -e "\nwindow size is too large, defaulting to 10."
                    ((projectDic["windowLength"]=10))
                    frontgate=1 
                    unset window_length
                else
                    ((projectDic["windowLength"]="${var}"))
                    frontgate=1 
                    unset window_length
                fi
            else
                echo -e "\nPlease enter a valid integer for window expansion size - defaulting to 1.\n"
                projectDic["windowLength"]=1
                frontgate=1 
                unset window_length
            fi
        elif [[ "${i,,}" == "-i" ]] || [[ ${input_file} == $i ]]; then ##Input file which grabs the input file name, location and complete file path
            if [[ "${var##*.}" == "vcf" ]] && [[ -f "$var" ]]; then ##Checks if it's VCF and if file exist
                projectDic["inputFile"]+="$var"
                projectDic["inputLoc"]+="${var%/*}"
                local filename=${var%.*} ##removes files extension
                filename=${filename##*/} ##removes file path
                projectDic["filename"]+="$filename"
                frontgate=1
                unset input_file
            else
                echo -e "\nERROR. Incorrect file input. Check file or directory path. (Input (.vcf) only)\nEXITING...\n"
                exit 1
            fi
        elif [[ "${i,,}" == "-o" ]] || [[ ${output_location} == $i ]]; then ##output location info
            if [ -d "$var" ]; then ##Checks if directory exist, if not it will save to input file location
                if [[ "${var: -1}" == "/" ]]; then
                    projectDic["outputLoc"]+="$var"
                else
                    projectDic["outputLoc"]+="$var"/
                fi
                frontgate=1
                unset output_location
            fi
        elif [[ "${i,,}" == "-p" ]] || [[ ${project_name} == $i ]]; then ##Project name
            projectDic["projectName"]="$var"
            frontgate=1
            unset project_name
        elif [[ "${i,,}" == "-f" ]] || [[ "${flanks}" == $i ]]; then ##Flank sizes for mutation motif's aln_to_counts func
            if [[ "$var" =~ ^[0-2]$ ]]; then ##Checks if it's a number and if it's between 0 and 2, Regex search
                ((projectDic["flanks"]="$var"))
            else
                echo -e "\nFlanks have to be between: 0 - 2. Defaulting to 0.\n"
                projectDic["flanks"]=0
            fi
            frontgate=1
            unset flanks
        elif [[ "${i,,}" == "-r" ]] || [[ ${referenceGenome} == $i ]]; then ##Which reference genome needed for FASTA file creation
            if [[ -f "${var}" ]]; then
                projectDic["referenceGenome"]="${var}"
                frontgate=1
                unset referenceGenome
            else
                echo -e "\nEnter a valid reference genome. Exiting...\n"
                exit 1
            fi
        elif [[ "${i}" == "-JOB" ]]; then
            local var=${args[${indexPos}+1]}
            projectDic["JOB"]="${var}"
        elif [[ "${i,,}" == "-n"  ]] || [[ "${indel_max_amount}" == $i ]]; then
            # echo -e "ATTACK_ONE"
            if [[ "${var}" =~ [0-9] ]]; then ##CHECK WITH PETER!!!
                # echo -e "ATTACK"
                if (( "$var" >= 25  && "$var" <= 100 )); then
                    ((projectDic["nMax"]="$var"))
                elif (( "$var" < 25 )); then
                    echo -e "\nMinimum indel threshold is 25. Defaulting to 25% threshold."
                    ((projectDic["nMax"]=25))
                elif (( "$var" > 100 )); then
                    echo -e "\nMaximum indel threshold is 100. Defaulting to 100% threshold."
                    ((projectDic["nMax"]=100))
                fi
                frontgate=1
                unset indel_max_amount     
            else
                echo -e "\nNot a valid indel threshold entry. Defaulting to 25%.\n"
                unset indel_max_amount         
            fi
            # if [[ "$var" =~ ^[0-9]+$ ]]; then
            #     if (( "${var}" >= 0  && "$var" <= 100 )); then
            #         ((projectDic["nMax"]+="$var"))
            #     elif (( "${var}" < 0 )); then
            #         echo -e "\nMinimum N threshold is 1. Defaulting to 1% threshold."
            #         ((projectDic["nMax"]+=1))
            #     elif (( "${var}" > 100 )); then
            #         echo -e "\nMaximum N threshold is 75. Defaulting to 100% threshold."
            #         ((projectDic["nMax"]+=100))
            #     fi
            #     frontgate=1                    
            # fi
        elif [[ "${i,,}" == "-ad"  ]] || [[ ${save_all_data} == $i ]]; then
            if [[ "${var,,}" == "true" ]] || [[ "${var,,}" == "false" ]]; then
                projectDic["allData"]="${var,,}"
                frontgate=1
                unset save_all_data
            else
                echo -e "No valid all data entry (true or false), defaulting to false. Only counts tables will be saved."
            fi
        elif [[ "${i,,}" == "-s3" ]] || [[ ${save_S3} == $i ]]; then ## ADD A CHECK FOR USERNAME AND PASSWORD
            if [[ "${var,,}" != "0" ]]; then
                if [[ "${var,,}" == "1" ]] || [[ "${var,,}" == "2" ]] || [[ "${var,,}" == "3" ]]; then
                    projectDic["s3"]="${var,,}"
                    frontgate=1
                    unset save_S3
                else
                    echo -e "No valid entry for S3 storage (true or false), defaulting to false."
                fi
            fi
        elif [[ "${i,,}" == "-dpb" ]] || [[ ${dropbox} == $i ]]; then ## ADD A CHECK FOR USERNAME AND PASSWORD 
            if [[ "${var,,}" == "true" ]] || [[ "${var,,}" == "false" ]]; then
                projectDic["dropbox"]="${var,,}"
                frontgate=1
                unset dropbox

            else
                echo -e "No valid entry for Dropbox uploading (true or false), defaulting to false."
            fi
        elif [[ "${i,,}" == "-gh" ]] || [[ ${save_github} == $i ]]; then ## ADD A CHECK FOR USERNAME AND PASSWORD 
            if [[ "${var,,}" == "true" ]] || [[ "${var,,}" == "false" ]]; then
                projectDic["github"]="${var,,}"
                frontgate=1
                unset save_github

            else
                echo -e "No valid entry for github uploading (true or false), defaulting to false."
            fi
        elif [[ "${i,,}" == "-msi" ]] || [[ ${MSI_Mode} == $i ]]; then
            if [[ "${var,,}" == "true" ]] || [[ "${var,,}" == "false" ]]; then
                projectDic["msi"]="${var,,}"
                frontgate=1
                unset MSI_Mode
            else
                echo -e "No valid entry for MSI mode (true or false), defaulting to false."
                projectDic["msi"]='false'
                frontgate=1
                unset MSI_Mode                
            fi
        elif [[ "${i,,}" == "-dpba" ]] || [[ ${dropbox_auth} == $i ]]; then
            projectDic["dropboxAuth"]="${var,,}"
            frontgate=1
            unset dropbox_auth
        elif [[ "${i,,}" == "-ghu" ]] || [[ ${gitUser} == $i ]]; then
            projectDic["gitUser"]="${var,,}"
            frontgate=1
            unset gitUser
        elif [[ "${i,,}" == "-ghp" ]] || [[ ${gitPass} == $i ]]; then
            projectDic["gitPass"]="${var,,}"
            frontgate=1
            unset gitPass
        elif [[ "${i,,}" == "-gho" ]] || [[ ${owner} == $i ]]; then
            projectDic["owner"]="${var,,}"
            frontgate=1
            unset owner
        elif [[ "${i,,}" == "-ghr" ]] || [[ ${Myrepository} == $i ]]; then
            projectDic["Myrepository"]="${var,,}"
            frontgate=1
            unset Myrepository           
        fi
        ((indexPos+=1))
    done
    if ((${frontgate} <= 0)); then
        echo -e "\nPlease enter valid arguments. None were valid.\n"
        exit 1
    fi
    if [[ ${projectDic["inputFile"]} == '' ]]; then
        echo -e "\nNo input file or working directory specified.\nEXITING...\n"
        exit 1
    fi
    if [[ -z ${projectDic["outputLoc"]} ]] && [[ ${projectDic["inputFile"]} != '' ]]; then
        echo -e "\nNot a valid output location. Re-routing to input file location.\n"
        projectDic["outputLoc"]+=${projectDic["inputLoc"]}
    fi
    if [[ ${projectDic["referenceGenome"]} == "" ]]; then
        echo -e "No reference genome enetered. Exiting..."
        exit 1
    fi
    if (( ${projectDic["flanks"]} > ${projectDic["windowLength"]} )); then
        echo -e "Flank larger than window expansion, defaulting to flank size of ${projectDic["flanks"]}"
        projectDic["windowLength"]=${projectDic["flanks"]}
    fi
    if [[ "${projectDic["dropbox"],,}" == "true" ]] && [[ "${projectDic["dropboxAuth"]}" == '' ]]; then 
        echo -e "Dropbox mode is set to true but there is no Generated access token was proved."
        echo -e "Changing Dropbox mode to false"
        projectDic["dropbox"]="false"
    fi
    if [[ "${projectDic["s3"]}" == "2" ]] || [[ "${projectDic["s3"],,}" == 3 ]]; then
        if [[ ! -d ~/.aws ]]; then 
            echo -e "AWS isn't set up in your home directory."
            echo -e "Changing S3 mode to false"
            projectDic["s3"]=0
        fi
    fi
    if [[ "${projectDic["github"],,}" == "true" ]]; then 
        if [[ "${projectDic[[ ["gitUser"]}" == '' ]] || /
        [[ "${projectDic["gitPass"]}" == '' ]] || /
        [[ "${projectDic["Myrepository"]}" == '' ]]; then
            echo -e "Github input parameters not filled out correctly, defaulting Github to false"
            echo -e "Changing Github mode to false"
            projectDic["github"]="false"
        fi
        if [[ "${projectDic["owner"]}" == "" ]]; then
            echo -e "Owner of Giithub repo not specified, defaulting to your username."
            projectDic["owner"]="${projectDic["gitUser"]}"
        fi
    fi

    unset startList
}

#    Loading modules on UMN MSI system. Three of the four are maintained by Morrell Lab (Corey Carter).
moduleLoader(){ #load modules need for operations
    if [[ "${projectDic["msi"],,}" == 'true' ]]; then
    
        # echo -e "\nExporting Morrell lab modules to your MODULEPATH.\n"
        export MODULEPATH=/panfs/roc/groups/9/morrellp/public/Modules:$MODULEPATH
        module load python3_ML/3.6.4
        module load bedops_ML/2.4.20
        module load bedtools_ML/2.23.0
    else
        declare -A testlisting=( ["python3"]=3.6.4 ["bedops"]=2.4.20 ["bedtools"]=2.23.0 )
        for inProgram in ${!testlisting[@]}; do
            if [[ -x $(command -v "${inProgram}") ]]; then
                if [[ "${inProgram}" == "python3" ]] && [[ $(python3 -c 'import sys; print(sys.version_info[0:2])') == '(3, 6)' ]]; then
                    if [[ ! $(python3 -c 'import sys; sys.tracebacklimit=0; import mutation_motif') ]]; then
                        echo -e "Python module Mutation Motif is not installed. Please follow the link for instrutions: (https://bitbucket.org/pycogent3/mutationmotif).\n"
                    fi
                    if $(( "${projectDic["s3"]}" > 0 ]] && [[ "${projectDic["s3"]}" <= 3 )); then
                        if [[ ! $(python3 -c 'import sys; sys.tracebacklimit=0; import boto3') ]]; then
                            echo -e "Python module boto3 (S3) is not installed. Please pip install boto3 for Amazon save S3 support. Use command: pip3 install boto3\n"
                        fi
                    fi
                    if [[ "${projectDic["dropbox"]}" == "true" ]] && [[ ! $(python3 -c 'import sys; sys.tracebacklimit=0; import dropbox') ]]; then
                        echo -e "Python module for dropbox is not installed. Please pip install dropbox for dropbox save support. Use command: pip3 install dropbox\n"
                    fi
                elif [[ ! "${inProgram}" == "python3" ]] && [[ ! $(python3 -c 'import sys; print(sys.version_info[0:2])') == '(3, 6)' ]]; then
                    echo -e "Python version out of date. Please install Python 3.6.x.\n"
                fi
            else
                echo -e "${inProgram} is not installed, please install ${inProgram} version: ${testlisting[$inProgram]}.\n"
            fi
        done
    fi

}

#    Performing vcf to bed conversion using bedops 'vcf2bed' function
fileConverter(){
    if [ "${projectDic[OperationalStage]}" == "vcfTObed" ]; then ##Key and new input LOCATION
        local temp="${projectDic["tempOut"]}"SPLITVCF/
        local splitDir=("${temp}"*_split_"${projectDic[filename]}".vcf*)
        for gene in "${splitDir[@]}"; do
            local targetVCF="${gene%.*}"
            targetVCF="${targetVCF##*/}"
            vcf2bed < "${gene}" > "${projectDic["tempOut"]}"BED_SPLIT/"${targetVCF}".bed & ##sort later
        done
        wait
        projectDic[OperationalStage]="bedTOfasta"
    #    Takes a reference genome and bed file and generates small fasta files from reference genome intervals
    elif [ "${projectDic[OperationalStage]}" == "bedTOfasta" ]; then
        local temp="${projectDic["tempOut"]}"BED_SPLIT/
        local splitDir=("${temp}"*"${projectDic[filename]}"_new_interval.bed*)
        for gene in "${splitDir[@]}"; do
            local targetBED="${gene%.*}"
            targetBED="${targetBED##*/}"
            targetBED=${targetBED:0:4}
            bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${gene}" -fo "${projectDic["tempOut"]}"FASTA_SPLIT/"${targetBED}"_"${projectDic[filename]}".fasta &
        done
        wait
        projectDic[OperationalStage]="alnToCounts"
    elif [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
        local temp="${projectDic["tempOut"]}"FASTA_SPLIT/
        local splitDir=("${temp}"*_"${projectDic[filename]}".fasta*)
        echo -e "creating counts tables..."
        for gene in "${splitDir[@]}"; do
            local countfile="${gene%.*}"
            countfile="${countfile##*/}"
            local geneDirection=${countfile:0:4}
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/LOGS
            for loopGene in "${dirL[@]}"; do
                aln_to_counts --align_path "${gene}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/ --flank_size "${projectDic[flanks]}" --direction "${loopGene}" -F > /dev/null
                mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/"${countfile}".txt "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/"${loopGene}"_"${geneDirection^^}"_"${projectDic[filename]}".txt
                mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/LOGS/"${loopGene}"_"${geneDirection^^}"_"${projectDic[filename]}".log ##FIX Unique Log ID'S            
            done
            active+=("${geneDirection}")
        done
        projectDic["OperationalStage"]="allCounts"
    elif [ "${projectDic[OperationalStage]}" == "allCounts" ]; then
        echo -e "creating combined tables..."
        mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/COMBINED_COUNTS
        for loopGene in "${active[@]}"; do
            cd "${projectDic[outputLoc]}"COUNTS_TABLES/"${loopGene}"/
            all_counts -c "*.txt*" -o "${projectDic[outputLoc]}"COUNTS_TABLES/"${loopGene}"/ --strand_symmetric > /dev/null 
            mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${loopGene}"/combined_counts.txt "${projectDic[outputLoc]}"COUNTS_TABLES/COMBINED_COUNTS/"${loopGene}"_combined_counts.txt
        done
        projectDic["OperationalStage"]="DONE..."
    fi

}

#    Creates output directories
dirStructure(){
    DATE=`date +"%m%d%Y-%H%M"`
    mkdir "${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
    projectDic["outputLoc"]="${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
    mkdir "${projectDic[outputLoc]}"COUNTS_TABLES
    if [[ ${projectDic["allData"]} == "true" ]]; then
        mkdir "${projectDic[outputLoc]}"SPLITVCF
        mkdir "${projectDic[outputLoc]}"FASTA_SPLIT
        mkdir "${projectDic[outputLoc]}"BED_SPLIT
        projectDic["tempOut"]="${projectDic[outputLoc]}"
    elif [[ ${projectDic["allData"]} == "false" ]]; then
        projectDic["TempLoc"]+=$(mktemp -d)
        mkdir "${projectDic[TempLoc]}"/SPLITVCF
        mkdir "${projectDic[TempLoc]}"/FASTA_SPLIT
        mkdir "${projectDic[TempLoc]}"/BED_SPLIT
        projectDic["tempOut"]="${projectDic["TempLoc"]}"/
    fi
}

s3Saver(){
    if [[ ${projectDic["iscmd"]} == "true" ]]; then
        config=("$@")
    else
        config="none"
    fi
    if [[ "${projectDic["s3"]}" != "0" ]]; then
        if [[ "${projectDic["s3"]}" == "1" ]] || [[ "${projectDic["mss3i"]}" == "3" ]]; then
            s3cmd mb s3://${projectDic["projectName"],,} > /dev/null
            echo -e "\nS3 bucket created..."
            echo -e "\ntransfering files..."
            if $(( s3cmd put --recursive "${projectDic["outputLoc"]}"COUNTS_TABLES/ s3://${projectDic["projectName"],,} > /dev/null )); then
                echo -e "\n Files transfered to S3...\n"
            else
                echo -e "S3 file transfer failed...\n"
            fi
        fi
        if [[ "${projectDic["msi"]}" == "2" ]] || [[ "${projectDic["msi"]}" == "3" ]]; then

            iscmd=${projectDic["iscmd"]} config=${config} project=${projectDic["projectName"]} output="${projectDic["tempOut"]}" python3.6 - << END_OF_TRANSFER

import boto3
import os
import io
import datetime

def s3sentit(inputLoc, project, iscmd, config):
    date = datetime.datetime.now() 
    allFiles={}
    currentDir = inputLoc
    s3 = boto3.resource('s3')
    my_session = boto3.session.Session()
    userRegion = my_session.region_name
    newFolder = project + "-countfiles" + "-" + date.strftime("%Y%m%d") + "-" + date.strftime("%H%M")
    s3.create_bucket(Bucket=newFolder, CreateBucketConfiguration={'LocationConstraint': userRegion})
    countsDirs = next(os.walk(currentDir + "COUNTS_TABLES/"))[1]
    for files in countsDirs:
        bottomDirs = currentDir + "COUNTS_TABLES/" + files + "/"
        [ allFiles.update({f: [bottomDirs + f, files]}) for f in os.listdir(bottomDirs) if os.path.isfile(bottomDirs + f) ]
        
    for file, path in allFiles.items():
        with open(path[0], "rb") as fileIO:
            myPath = path[1] + "/" + file
            s3.Object(newFolder, myPath).upload_fileobj(fileIO)                     
    if( iscmd == "true"):
        out=''
        with open(config, "r") as configScanner:
            out_buffer = io.BytesIO()
            line_counter = 0  
            for i in configScanner.readlines():
                if(i.startswith("dropbox_auth")):
                    out="dropbox_auth=***REDACTED*** removed to maintain account security.\n"
                elif(i.startswith("gitPass")):
                    out="gitPass=***REDACTED*** removed to maintain account security.\n"
                elif(i.startswith("input_email")):
                    out="input_email=***REDACTED*** removed to maintain account security.\n"
                else:
                    out=i
                out_buffer.write(out.encode())
                line_counter += 1
            out_buffer.seek(0)
            s3.Object(newFolder, "context.config").upload_fileobj(out_buffer)
            out_buffer.close()    

def bashimports():
    project = str(os.environ['project'])
    inputLoc = str(os.environ['output'])
    iscmd = str(os.environ['iscmd'])
    config = str(os.environ['config'])
    return(inputLoc, project, iscmd, config)

def main():
    output, project, iscmd, config=bashimports()
    s3sentit(output, project, iscmd, config)

main()

END_OF_TRANSFER

        fi

    fi

    echo -e "S3 transfer complete.\n"

}

dropboxSaver(){
    if [[ ${projectDic["iscmd"]} == "true" ]]; then
        config=("$@")
    else
        config="none"
    fi
    iscmd=${projectDic["iscmd"]} config=${config} project=${projectDic["projectName"]} output="${projectDic["tempOut"]}" dbAuth="${projectDic["dropboxAuth"]}" python3.6 - << END_OF_TRANSFER

import dropbox
import os
import datetime

def dpsentit(inputLoc, project, dbAuth, iscmd, config):
    date = datetime.datetime.now()
    allFiles={}
    currentDir = inputLoc  
    dbx = dropbox.Dropbox(dbAuth)
    newFolder = "/" + project + "-countfiles" + "-" + date.strftime("%Y%m%d") + "-" + date.strftime("%H%M")
    countsDirs = next(os.walk(inputLoc + "COUNTS_TABLES/"))[1]
    for files in countsDirs:
        bottomDirs = currentDir + "COUNTS_TABLES/" + files + "/"        
        [ allFiles.update({f: [bottomDirs + f, files]}) for f in os.listdir(bottomDirs) if os.path.isfile(bottomDirs + f) ]
    for file, path in allFiles.items():
        with open(path[0], 'rb') as sendDP:
            myPath= newFolder + "/" + path[1] + "/" + file
            dbx.files_upload(sendDP.read(), myPath, mode=dropbox.files.WriteMode.overwrite)

    if( iscmd == "true"):
        out=''
        with open(config, "r") as configScanner:
            for i in configScanner.readlines():
                if(i.startswith("dropbox_auth")):
                    out+="dropbox_auth=***REDACTED*** removed to maintain account security.\n"
                elif(i.startswith("gitPass")):
                    out+="gitPass=***REDACTED*** removed to maintain account security.\n"
                elif(i.startswith("input_email")):
                    out+="input_email=***REDACTED*** removed to maintain account security.\n"
                else:
                    out+=i            
        outBytes = out.encode()
        dbx.files_upload(outBytes, newFolder + "/context.config", mode=dropbox.files.WriteMode.overwrite)

def bashimports():
    dbAuth = str(os.environ['dbAuth'])    
    project = str(os.environ['project'])
    inputLoc = str(os.environ['output'])
    iscmd = str(os.environ['iscmd'])
    config = str(os.environ['config'])
    return(inputLoc, project, dbAuth, iscmd, config)

def main():
    inputLoc, project, dbAuth, iscmd, config=bashimports()
    dpsentit(inputLoc, project, dbAuth, iscmd, config)
    
main()

END_OF_TRANSFER

    echo -e "Dropbox transfer complete.\n"

}

gitHubSendIt() {
    if [[ ${projectDic["iscmd"]} == "true" ]]; then
        config=("$@")
    else
        config="none"
    fi
           iscmd=${projectDic["iscmd"]} config=${config} project=${projectDic["projectName"]} output="${projectDic["tempOut"]}" gitUser="${projectDic["gitUser"]}" gitPass="${projectDic["gitPass"]}" repo="${projectDic["repo"]}" gitowner="${projectDic["gitowner"]}" python3.6 - << END_OF_TRANSFER

import os
import github3
import datetime

def githubSend(inputLoc, project, gitUser, gitPass, Myrepository, owner, iscmd, config):
    date = datetime.datetime.now() 
    allFiles={}
    currentDir = inputLoc

    gh = github3.login(username=gitUser, password=gitPass)
    repo = gh.repository(owner=owner, repository=Myrepository)

    newFolder = project + "-countfiles" + "-" + date.strftime("%Y%m%d") + "-" + date.strftime("%H%M")
    countsDirs = next(os.walk(currentDir + "COUNTS_TABLES/"))[1]

    for files in countsDirs:
        bottomDirs = currentDir + "COUNTS_TABLES/" + files + "/"   
        [ allFiles.update({f: [bottomDirs + f, files]}) for f in os.listdir(bottomDirs) if os.path.isfile(bottomDirs + f) ]
    
    for file, path in allFiles.items():
        with open(path[0], "rb") as fileIO:
            direction = fileIO.read()
        myPath= newFolder + "/" + path[1] + "/" + file
        repo.create_file(path=myPath, message="Uploading " + file, content=direction)
    
    if( iscmd == "true"):
        out=''
        with open(config, "r") as configScanner:
            for i in configScanner.readlines():
                if(i.startswith("dropbox_auth")):
                    out+="dropbox_auth=***REDACTED*** removed to maintain account security.\n"
                elif(i.startswith("gitPass")):
                    out+="gitPass=***REDACTED*** removed to maintain account security.\n"
                elif(i.startswith("input_email")):
                    out+="input_email=***REDACTED*** removed to maintain account security.\n"
                else:
                    out+=i
        outBytes = out.encode()
        repo.create_file(path=newFolder + "/context.config", message="Uploading Config file", content=outBytes)

def bashimports():
    project = str(os.environ['project'])
    inputLoc = str(os.environ['output'])
    gitUser = str(os.environ['gitUser'])
    gitPass = str(os.environ['gitPass'])
    Myrepository = str(os.environ['repo'])
    owner = str(os.environ['gitowner'])
    iscmd = str(os.environ['iscmd'])
    config = str(os.environ['config'])  
    return(inputLoc, project, gitUser, gitPass, Myrepository, owner, iscmd, config)

def main():
    inputLoc, project, gitUser, gitPass, Myrepository, owner, iscmd, config = bashimports()
    githubSend(inputLoc, project, gitUser, gitPass, Myrepository, owner, iscmd, config)

main()

END_OF_TRANSFER

    echo -e "Counts table data and config file sent to your github"

}

#    This is Python 3 code embedded in the bash script
#    Expands coverage windows based on user-specified intervals
#    Also checks for "Type One" and "Type Two" overlaps
#    A "Type One overlap" is another SNP within immediate contextual sequence
#    A "Type Two overlap" is another SNP within the expanded flanking contextual sequencing
pythonBEDScanner(){
    inputFile="${projectDic["inputFile"]}" baseOut="${projectDic["outputLoc"]}" outputLoc="${projectDic["tempOut"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" interval="${projectDic["windowLength"]}" geneDir="$geneDir" python3.6 - <<END_OF_PYTHON
    
import os
import re
import subprocess
from itertools import chain
import datetime

def bedMapper(interval, outputLoc, projectName, filename, geneDir):
    output = str(subprocess.check_output(['wc', '-m', outputLoc + "BED_SPLIT/" + geneDir + "_split_" + filename + ".bed"]))
    length = re.findall(r'\d+', output)
    length = int(length[0])
    bedMapper=bytearray()
    masterList=[]
    sub=[] ##FOR BEDMAPPER
    temp=[] ##FOR MASTERLIST
    final=''
    with open(outputLoc + "BED_SPLIT/" + geneDir + "_split_" + filename + ".bed", "rb") as bed_test: ##Change to input variables
        for i in range(length):
            element = bed_test.read(1).decode("ascii")
            if((element != '\t') and (element != '\n')):
                final = final + element
            elif((element == '\t') and (element != '\n')):
                sub.append(final)
                final=''
                sub.append(element)
            if(element == "\n"):
                sub.append(final)
                sub.append(element)
                sub[2] = str(int(sub[2]) - interval)
                sub[4] = str(int(sub[4]) + interval)         
                a = sub[2]
                b = sub[4]
                temp.append(int(a))
                temp.append(int(b))
                temp.sort()
                bedMapper.extend(''.join(sub).encode("utf-8"))
                masterList.append(temp)
                final=''
                sub=[] ## was sub=[]
                temp=[] ## was sub=[]
        with open(outputLoc + "BED_SPLIT/" + geneDir + "_" + filename + "_new_interval.bed", "wb") as newBed: ##Change to input variables
            newBed.write(bedMapper)
        return(masterList)

def binaryIntersect(expandedList, interval, outputLoc, projectName, filename, geneDir, baseOut):
    gateA=True
    gateB=True
    now = datetime.datetime.now()
    results = '\n**********************\nTYPE ONE and TYPE TWO CHECKS FOR: ' + geneDir + " ON " + now.strftime("%Y-%m-%d, %H:%M") + '\n----------------------------------------------------\n' ##ADD PROJECT NAME TO THIS
    resultsA = '\n**' + geneDir + ' TYPE ONE: OVERLAPS INTO ORIGINAL SNPs**\n------------------------------------\n'
    resultsB = '\n**' + geneDir + ' TYPE TWO: OVERLAPS INTO SNP EXPANSION WINDOWS**\n-------------------------------------\n'
    for i in range(len(expandedList)-1): #Checks for Type One SNP overlaps (ORIGINAL INTERVAL CHECK)
            a=expandedList[i][0] ##A= left side
            b=expandedList[i][1] ##B= right side
            subTA=expandedList[i+1][0]-(interval) ##TYPE ONE SWITCHED FROM - TO +
            subTB=expandedList[i+1][1]+(interval) ##TYPE ONE SWITCHED FROM - TO +
            subMA=expandedList[i+1][0] ##TYPE TWO
            subMB=expandedList[i+1][1] ##TYPE TWO
            binary=[0,0,0,0]
            binaryMB=[0,0,0,0]
            if(a <= subTA):
                binary[0]=1
            if(a <= subTB):
                binary[1]=1
            if(b >= subTA):
                binary[2]=1
            if(b >= subTB):
                binary[3]=1
            if(a <= subMA): ##
                binaryMB[0]=1
            if(a <= subMB):
                binaryMB[1]=1
            if(b >= subMA):
                binaryMB[2]=1
            if(b >= subMB):
                binaryMB[3]=1
            if((binary != [1,1,0,0]) and (binary != [0,0,1,1])):
                gateA=False
                if(binary == [0,1,1,0]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subTA) + "-" + str(subTB) + '.'
                elif(binary == [1,1,1,1]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subTA) + "-" + str(subTB) + '.'
                elif((binary == [1,1,1,0]) or (binary == [0,1,1,1])):
                    if(binary == [1,1,1,0]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the right, between " + str(b) + " and " + str(subTA) + '.'
                    elif(binary == [0,1,1,1]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the left, between " + str(a) + " and " + str(subTB) + '.' 
            if((binaryMB != [1,1,0,0]) and (binaryMB != [0,0,1,1])):
                gateB=False
                if(binaryMB == [0,1,1,0]):
                    resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subMA) + "-" + str(subMB) + '.'
                elif(binaryMB == [1,1,1,1]):
                    resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subMA) + "-" + str(subMB) + '.'
                elif((binaryMB == [1,1,1,0]) or (binaryMB == [0,1,1,1])):
                    if(binaryMB == [1,1,1,0]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the right, between " + str(b) + " and " + str(subMA) + '.'
                    elif(binaryMB == [0,1,1,1]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the left, between " + str(a) + " and " + str(subMB) + '.' 
    if(gateA):
        resultsA+="\nNo Type ONE window overlaps detected.\n"
    if(gateB):
        resultsB+="\nNo Type TWO window overlaps detected.\n"
    results += resultsA + "\n" + resultsB + "\n"
    results += "\nEND OF INTERVAL CHECKS.\nXXXXXXXXXXXXXXXXXXXXXX\n"
    with open(baseOut + projectName + "_" + "WindowOverlap.txt", 'a+') as window:
        window.write(results)
        
def bashInputs():
    outputLoc=str(os.environ['outputLoc'])
    filename=str(os.environ['filename'])
    interval=int(os.environ['interval'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    geneDir=str(os.environ['geneDir'])
    baseOut=str(os.environ['baseOut'])
    return(outputLoc, filename, interval, inputFile, projectName, geneDir, baseOut)

def main():
    outputLoc, filename, interval, inputFile, projectName, geneDir, baseOut=bashInputs()
    masterList=bedMapper(interval, outputLoc, projectName, filename, geneDir) 
    binaryIntersect(masterList, interval, outputLoc, projectName, filename, geneDir, baseOut)
main()

END_OF_PYTHON

}

vcfSplit(){
    inputFile="${projectDic["inputFile"]}" baseOut="${projectDic["outputLoc"]}" outputLoc="${projectDic["tempOut"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" python3.6 - <<VCF_SPLIT_END

import os

def geneDirCreate():
    geneDir={

        'AtoC':bytearray(),
        'AtoG':bytearray(),
        'AtoT':bytearray(),
        'CtoA':bytearray(),
        'CtoG':bytearray(),
        'CtoT':bytearray(),
        'GtoA':bytearray(),
        'GtoC':bytearray(),
        'GtoT':bytearray(),
        'TtoA':bytearray(),
        'TtoC':bytearray(),
        'TtoG':bytearray(),
        'rejected':bytearray(),
        'header':bytearray(),
        
    }
    return(geneDir)

def vcfSegments(inputFile, geneDir):
    with open(inputFile, "rb") as raw:
        sub=[]
        counter=0
        gene=''
        results=''
        for readLine in raw:
            sub.clear()
            gene=''
            results=''
            gate=True
            counter=0
            while((gate == True) and (counter <= len(readLine))):
                element = chr(readLine[counter])
                if((element != '#') or (chr(readLine[0]) != "#")):                                
                    if((element != '\t') and (element != '\n')):
                        results = results + element
                    elif((element == '\t') and (element != '\n')):
                        sub.append(results)
                        sub.append(element)
                        results=''
                    if((element == "\n") or (len(sub) == 9)):
                        gene= str(sub[6]) + "to" + str(sub[8])
                        if gene in geneDir:
                            geneDir[gene].extend(readLine)
                            sub.clear()
                            gate=False
                        else:
                            geneDir['rejected'].extend(readLine)
                            sub.clear()
                            gate=False
                else:
                    geneDir['header'].extend(readLine)
                    gate=False
                counter+=1
    return(geneDir)

def vcfSpliter(geneDir, outputLoc, filename, baseOut):
    for key in geneDir:
        if(geneDir[key]):
            if((key != "rejected") and (key != "header")):
                with open(outputLoc + "SPLITVCF/" + key + "_split_" + filename + ".vcf","ab") as vcfOut:
                    vcfOut.write(geneDir['header'])
                    vcfOut.write(geneDir[key])
            else:
                if(key != "header"):
                    with open(baseOut + "REJECTEDVCFs_" + filename + ".vcf","ab") as vcfOut:
                        vcfOut.write(geneDir['header'])
                        vcfOut.write(geneDir[key])

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    inputFile=str(os.environ['inputFile'])
    filename=str(os.environ['filename'])
    projectName=str(os.environ['projectName'])
    baseOut=str(os.environ['baseOut'])
    return(projectName, inputFile, outputLoc, filename, baseOut)

def main():
    projectName, inputFile, outputLoc, filename, baseOut=bashImport()
    geneDir=geneDirCreate()
    geneDir=vcfSegments(inputFile, geneDir)
    vcfSpliter(geneDir, outputLoc, filename, baseOut)

main()

VCF_SPLIT_END

}

fastaScanner(){

    inputFile="${projectDic["inputFile"]}" flank="${projectDic["flanks"]}" baseOut="${projectDic["outputLoc"]}" outputLoc="${projectDic["tempOut"]}" filename="${projectDic["filename"]}" geneTwo=${geneTwo} geneDirTwo="${geneDirTwo}" nMax="${projectDic["nMax"]}" windowLength="${projectDic["windowLength"]}" python3.6 - <<FASTA_SWEEP
    
from itertools import chain
import os

def fastaMapper(gene):
    with open(gene ,"rb") as fasta:
        fastafile=fasta.read()
        totalN=0
        master=[]
        sub=[]
        final=''
        for counter, i in enumerate(fastafile):
            element=chr(i)
            if(element == 'N'):
                totalN+=1
            if((element != "\n") and (element != ">")):
                final = final + str(element)
            if((element == "\n") and (element != ">")):
                final = final + str(element)
                sub.append(final)
                final=''
            if((element == ">") and (element != "\n")):
                if(sub != []):
                    if(sub[0] != ">"):
                        sub = [u.upper() for u in sub]
                    master.append(sub)
                    sub=[]
                    final=''
                    final = final + str(element)
                else:
                    final = final + str(element)
            if(counter == (len(fastafile)-1)):
                final = final + str(element)
                sub.append(final)
                master.append(sub)
    return(master)

def fastaNpop(subMaster, allRejected, nMax):
    maxP=nMax/100
    newsubMaster=[]
    nMaxList=[]
    for subListing in subMaster:
        totalN = len([x for x in subListing[1] if x == "N"])
        nPercent=totalN/len(subListing[1])
        if(nPercent >= maxP):
            nMaxList.append(subListing)
        else:
            newsubMaster.append(subListing)
    return(newsubMaster, nMaxList)

def fastaBasePop(master, interval, flank):
    allRejected=False
    subMaster=[]
    nList=[]
    if(interval > 2):
        Linterval=interval - flank ##change to 4
        Rinterval=interval - (flank - 1) ##change to 4
    else:
        Linterval=0 ##change to 4
        Rinterval=-1 ##change to 4
    for element in master: ##CHANGE TO SUBTRACT CORRECT DISTANCES
        baseIn = element[1][(Linterval):-(Rinterval)] ##MAYBE add +1 on Rinterval.
        if("N" not in baseIn):
            subMaster.append(element)
        else:
            nList.append(element)
    if(len(subMaster) == 0):
        allRejected=True
    return(subMaster, allRejected, nList)

def fileSaver(subMaster, master, nList, nMaxList, gene, allRejected, baseOut, filename, geneDirTwo, outputLoc):
    if(allRejected != True):
        with open(gene,"w") as newFasta:
            output="".join(chain.from_iterable(subMaster))
            newFasta.write(output)
    else:
        with open(baseOut + "FASTA_SPLIT/" + geneDirTwo + filename + ".fasta","w") as newFasta:
            output="".join(chain.from_iterable(master))
            newFasta.write(output)
        os.rename(outputLoc + "FASTA_SPLIT/" + geneDirTwo + filename + ".fasta", outputLoc + "ALLREJECTED_" + geneDirTwo + "_" + filename + ".fasta")
    if(len(nList) != 0):
        with open(baseOut + "N-BASE_FAILED_FASTAS.fasta","a") as newFasta:
            output="".join(chain.from_iterable(nList))
            newFasta.write(output)
    if(len(nMaxList) != 0):
        with open(baseOut + "N-THRESHOLD_FAILED_FASTAS.fasta","a") as newFasta:
            output="".join(chain.from_iterable(nMaxList))
            newFasta.write(output)

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    flank=int(os.environ['flank'])
    filename=str(os.environ['filename'])
    gene=str(os.environ['geneTwo'])
    nMax=int(os.environ['nMax'])
    geneDirTwo=str(os.environ['geneDirTwo']) ##GENE Direction
    interval=int(os.environ['windowLength'])
    baseOut=str(os.environ['baseOut'])
    return(flank, outputLoc, filename, gene, geneDirTwo, interval, nMax, baseOut)

def main():
    flank, outputLoc, filename, gene, geneDirTwo, interval, nMax, baseOut = bashImport()
    master=fastaMapper(gene)
    subMaster, allRejected, nList = fastaBasePop(master, interval, flank)
    subMaster, nMaxList = fastaNpop(subMaster, allRejected, nMax)
    fileSaver(subMaster, master, nList, nMaxList, gene, allRejected, baseOut, filename, geneDirTwo, outputLoc)

main()

FASTA_SWEEP

}

jobCreator(){
    scriptPath="$( cd "$( dirname "${BASH_SOURCE[0]}" )" > /dev/null && pwd -P )" ## Grabs the file path location for script
    qsub -l "${job_specs}" -m abe -o "${projectDic["tempOut"]}" -e "${projectDic["tempOut"]}" -M "${input_email}" -N "${projectDic["projectName"]}" "${scriptPath}"/update_SNP \
    -i "${projectDic["inputFile"]}" \
    -o "${projectDic["outputLoc"]}" \
    -w "${projectDic["windowLength"]}" \
    -f "${projectDic["flanks"]}" \
    -p "${projectDic["projectName"]}" \
    -r "${projectDic["referenceGenome"]}" \
    -ad "${projectDic["allData"]}" \
    -n "${projectDic["nMax"]}" \
    -JOB "${projectDic["THIS_IS_A_JOB"]}" \
    -s3 "${projectDic["s3"]}" \
    -msi "${projectDic["msi"]}" \
    -dpb "${projectDic["dropbox"]}" \
    -dpba "${projectDic["dropboxAuth"]}" \

}

# jobCreator(){
#     myEmail="${projectDic["email"]}" nMax="${projectDic["nMax"]}" allData="${projectDic["allData"]}" inputFile="${projectDic["inputFile"]}" outputLoc="${projectDic["outputLoc"]}" projectName="${projectDic["projectName"]}" windowLength="${projectDic["windowLength"]}" flanks="${projectDic["flanks"]}" referenceGenome="${projectDic["referenceGenome"]}" python3.6 - <<JOB_CREATED

# import os

# def jobScript(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax):
#     job="#!/bin/bash -l\n\n#PBS -l walltime=24:00:00,nodes=2:ppn=10,mem=20gb\n#PBS -m abe\n#PBS -M " + email + "\n"
#     job+="#PBS -N " + projectName + "_" + "SNP-Context" + "\nset -e\nset -o pipefail\n\n"
#     job+="#PBS -o " + outputLoc + "_" + projectName + "\n#PBS -e " + outputLoc + "_" + projectName + "\n"
#     job+="\nmodule load snpcontext/1.0.0\n\n"
#     job+="/panfs/roc/groups/9/morrellp/public/Software/SNP_Context/SNPcontext "
#     job+= "-i " + inputFile + " "
#     job+= "-o " + outputLoc + " "
#     job+= "-w " + windowLength + " "
#     job+= "-f " + flanks + " "
#     job+= "-p " + projectName + " "
#     job+= "-r " + referenceGenome + " "
#     job+= "-ad " + allData + " "
#     job+= "-n " + nMax + " "
#     job+= "-JOB THIS_IS_A_JOB"

#     with open(outputLoc + projectName + ".job", "w") as jobScript:
#         jobScript.write(job)

# def bashImport():
#     outputLoc=str(os.environ['outputLoc'])
#     email=str(os.environ['myEmail'])
#     flanks=str(os.environ['flanks'])
#     referenceGenome=str(os.environ['referenceGenome'])
#     windowLength=str(os.environ['windowLength'])
#     inputFile=str(os.environ['inputFile'])
#     projectName=str(os.environ['projectName'])
#     allData=str(os.environ['allData'])
#     nMax=str(os.environ['nMax'])
#     return(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax)

# def main():
#     projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax = bashImport()
#     jobScript(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax)

# main()
    
# JOB_CREATED

# qsub "${projectDic["outputLoc"]}""${projectDic["projectName"]}".job
# echo -e "\njob submited.\nEXITING...\n"
# exit 0

# }

main(){
    config_check "$@"
    if [[ "${projectDic["JOB"]}" != "THIS_IS_A_JOB" ]] && [[ "${projectDic["msi"]}" == 'true' ]]; then
        module load python3_ML/3.6.4
        jobCreator
    fi
    moduleLoader ##LOADS CORRECT MODULES        
    dirStructure
    vcfSplit
    fileConverter ##MAKES BED FILE
    local temp="${projectDic["tempOut"]}"BED_SPLIT/
    local splitDir=("${temp}"*_split_"${projectDic[filename]}".bed*)
    for gene in "${splitDir[@]}"; do
        local geneDir="${gene%.*}"
        geneDir="${geneDir##*/}"
        geneDir=${geneDir:0:4} ##BASH IS BASE 1
        pythonBEDScanner "$geneDir" & ##EXPANDS BED FILE WINDOWS AND CHECKS FOR OVER LAP
    done
    wait
    echo -e "\nOverlap checks completed..."
    echo -e "See Overlap results located in 'WindowOverlap.txt' in your main output directory.\n"
    fileConverter ##CREATES FASTA FILE
    local tempTwo="${projectDic["tempOut"]}"FASTA_SPLIT/
    local fastalisting=("${tempTwo}"*_"${projectDic[filename]}".fasta*)
    for geneTwo in "${fastalisting[@]}"; do
        local geneDirTwo="${geneTwo%.*}"
        geneDirTwo="${geneDirTwo##*/}"
        geneDirTwo=${geneDirTwo:0:4}
        fastaScanner "${geneDirTwo}" "${geneTwo}" & ##COPIES MASTER FASTA FILE 12 TIMES FOR ALN_TO_COUNTS
    done
    wait
    fileConverter ##ALN_TO_COUNTS TABLES WHICH ARE FED INTO ALL_COUNTS
    fileConverter ##ALL_COUNTS
    if [[ "${projectDic["allData"]}" == "false"  ]]; then
        local templocation="${projectDic["TempLoc"]}"
        rm -rf "${templocation}"
    fi
    ##Add dropbox intergration
    if [[ "${projectDic["s3"]}" != "0" ]]; then
        s3Saver "$@"
    fi
    if [[ "${projectDic["dropbox"]}" == 'true' ]]; then
        dropboxSaver "$@"
    fi
    if [[ "${projectDic["github"]}" == 'true' ]]; then
        gitHubSaver "$@"
    fi
    echo -e "operations completed...\n"
        
}

main "$@"