#!/bin/bash

#    Corey Carter, St. Paul, MN - 09 January 2018
#    This bash script is designed to pull contextual sequence flanking a SNP (variants) from a reference genome.
#    The window size for contextual sequence can be user specificed.
#    The program checks for the presence of more than one variant within user specified windows.

#     A bash dictionary for input parameters

# XXXX
declare -A projectDic=(
    ["windowLength"]=1 #-w
    ["inputFile"]='' #-i0
    ["inputLoc"]=''
    ["outputLoc"]='' #-o
    ["filename"]=''
    ["projectName"]='out' #-p
    ["flanks"]=0 #-f
    ["referenceGenomeChar"]=''
    ["referenceGenome"]='' #-r
    ["OperationalStage"]='vcfTObed'
    ["nMax"]=25 ##-n
    ["JOB"]='NO_JOB_NOW'
    ["TempLoc"]=''
    ["tempOut"]=''
    ["allData"]='false' #-ad
    ["S3"]='false' #####
    
)
# XXXX
#     A bash list of all possible nucleotide state transitions
declare -a dirL=('AtoC' 'AtoG' 'AtoT' 'CtoA' 'CtoG' 'CtoT' 'GtoA' 'GtoC' 'GtoT' 'TtoA' 'TtoC' 'TtoG')

# XXXX
declare -a active=()

# XXXX
config_check(){
    local configCheck=("$@")
    if (( "$#" == 1 )); then
        if [[ ${configCheck[0],,} == "--help" ]] || [[ ${configCheck[0],,} == "-h" ]] || (( "$#" == 0 )); then
            local helpPrintOut=$'\n\tSNP context\n\tList of commands:\n\t------------------------\n'
            helpPrintOut+=$'\nSNPcontext -i <input VCF> -o <output> -r <reference genome> -w <expansion size> -f <flank size> -p <project name> -n <acceptable Indel %> -ad <saved all data>\n'
            helpPrintOut+=$'\n\t------------------------\n'
            helpPrintOut+=$'\n\t**Input arguments can be in ANY order.**\n'
            helpPrintOut+=$'\n\t-i [(complete path to VCF file) (the VCF input file)]\n\t-o [(complete path to location) (The output location, if not entered it will default to the same location as your input file.)]'
            helpPrintOut+=$'\n\t-r [(barley or b, soy bean or s )(Selects the reference genome, defaults to Barley if not specified.)]\n\t-w [(Expansion window size)(The expandable window size around the SNP location, 8 on both ends is the deafult.)]'
            helpPrintOut+=$'\n\t-p [project name]\n\t-n [max percentage of indels allowed in fasta files]'
            helpPrintOut+=$'\n\t-a [(true/false) Do you want all temp files (vcf,bed and fasta) to be saved in your output directory]'
            helpPrintOut+=$'\n\t-f [(number between 0 and 2) (flank size for aln_to_counts)]'
            helpPrintOut+=$'\n\t-n [(number)(The percentage of accepted indels in the FASTA file)]'
            helpPrintOut+=$'\n\t-ad [(true or false) (Which stands for “all data”, this allows you to keep all intermediate files (split VCFs, BED, new interval BEDs, FASTA files)\n\t    that are normally deleted after processing. Defaults to false, which deletes intermedidate files.)]\n'
            echo "$helpPrintOut"
            exit -0
        elif [[ -f ${configCheck[0]} ]] && [[ ${configCheck[0]##*/} == "context.config" ]]; then
            echo -e "CONFIG LOADER"
            config_starter "${configCheck}"
            return 0 ##CHECK
        fi
    fi
    echo -e "STARTER"
    starter "$@"
}

# REMOVING IT!!!
config_starter(){
    source "${configCheck}" ##CHECK IF IT'S RIGHT
    if [[ "${window_length}" =~ ^[0-9]+$ ]]; then ##Checks if it's a number, max expansion of 1000.
        if (( "${window_length}" >= 1)); then ##Changed from 2 to 1
            ((projectDic["windowLength"]+="${window_length}"))
        fi
    else
        echo -e "\nPlease enter a valid integer for window expansion size, defaulting to 1 bases or flank size.. TEST TEST..\n"
        exit 1
    fi
    # projectDic["windowLength"]=window_length.
    if [[ "${input_file}" != '' ]] && [[ "${input_file##*.}" == "vcf" ]] && [ -f "${input_file}" ]; then
        projectDic["inputFile"]+="${input_file}"
        projectDic["inputLoc"]+="${input_file%/*}"
        local filename=${input_file%.*} ##removes files extension
        filename="${filename##*/}" ##removes file path
        projectDic["filename"]+="${filename}"
    else
        echo -e "\nERROR. Incorrect file input. Check file is valid or directory path. (Input (.vcf) only)\nEXITING...\n"
        exit 1
    fi
    # projectDic["inputFile"]=input_file
    if [[ -z "${output_location}" ]]; then
        echo -e "\nNot a valid output location. Re-routing to input file location.\n"
        projectDic["outputLoc"]+="${projectDic["inputLoc"]}"
    fi
    if [ -d "$output_location" ]; then ##Checks if directory exist, if not it will save to input file location
        if [[ "${output_location: -1}" == "/" ]]; then
            projectDic["outputLoc"]+="${output_location}"
        else
            projectDic["outputLoc"]+="${output_location}"/
        fi
    fi
    # projectDic["outputLoc"]=output_location
    projectDic["projectName"]="${project_name}"
    if [[ "${flanks}" =~ ^[0-2]+$ ]]; then ##Checks if it's a number and if it's between 0 and 2
        ((projectDic["flanks"]+="${flanks}"))
        if (( ${projectDic["flanks"]} > ${projectDic["windowLength"]} )); then
            ${projectDic["windowLength"]}=${projectDic["flanks"]}
        fi
    else
        echo -e "\nFlanks have to be between: 0 - 2. Defaulting to 0.\n"
    fi
    # projectDic["flanks"]=flanks CHECK if im doing this right.
    # if [[ -e "${referenceGenome}" ]]; then
    #     if [[ "${referenceGenome##*.}" == "fasfa" ]] || [[ "${referenceGenome##*.}" == "fa" ]]; then
    #         projectDic["referenceGenome"]="${referenceGenome}"
    #     else
    #         referenceAssignment ${referenceGenome}
    #     fi            
    # else
    #     referenceAssignment ${referenceGenome}
    # fi
    echo -e "\n${referenceGenome}\n"
    if [[ -f "${referenceGenome}" ]]; then
    echo -e "INTO THE BREACH\n"
        if [[ "${referenceGenome##*.}" == "fasfa" ]] || [[ "${referenceGenome##*.}" == "fa" ]]; then
            echo -e "IF ONE\n"
            projectDic["referenceGenome"]="${referenceGenome}"
        else
            echo -e "ELSE ONE\n"
            referenceAssignment ${referenceGenome}
        fi            
    else
        echo -e "ELSE BREACH\n"
        referenceAssignment ${referenceGenome}
    fi
    if [[ "${indel_max_amount}" =~ ^[0-9]+$ ]]; then
        if (( "${indel_max_amount}" >= 0  && "${indel_max_amount}" <= 100 )); then
            ((projectDic["nMax"]+="$indel_max_amount"))
        elif (( "${indel_max_amount}" < 0 )); then
            echo -e "\nMinimum N threshold is 1. Defaulting to 1% threshold."
            ((projectDic["nMax"]+=1))
        elif (( "${indel_max_amount}" > 100 )); then
            echo -e "\nMaximum N threshold is 75. Defaulting to 100% threshold."
            ((projectDic["nMax"]+=100))
        fi            
    fi
    # projectDic["nMax"]=indel_max_amount
    projectDic["allData"]=${save_all_data,,}
    # projectDic["dropBox"]=dropbox
    # projectDic["oneDrive"]=onedrive
    if [[ "${msi_S3}" == "" ]]; then
        echo -e "Null space, defaulting to false...\n"
        projectDic["S3"]='false'
    else ##ADD SOMETHING TO CHECK IF IT'S ONLY true OR false
        echo -e "MSI S3 SPLIT!\n"
        projectDic["S3"]="${msi_S3,,}"
    fi
}

# XXXX
#     Takes user arguments from command line and assigns values to dictionary keys in 'projectDic'
starter(){ #grabs the arguments
    # local args=("$@")
    local frontgate=0
    local indexPos=0
    for i in $@; do
        if [[ "${i,,}" == "-w" ]]; then ##Window expansion size
            local var=${args[${indexPos}+1]}
            if [[ "$var" =~ ^[0-9]+$ ]]; then ##Checks if it's a number, max expansion of 1000.
                if (( "$var" >= 1)); then ##Changed from 2 to 1
                    ((projectDic["windowLength"]+="$var"))
                    frontgate=1 
                fi
            else
                echo -e "\nPlease enter a valid integer for window expansion size, defaulting to 1 bases or flank size.\n"
            fi
        elif [[ "${i,,}" == "-i" ]]; then ##Input file which grabs the input file name, location and complete file path 
            local var=${args[${indexPos}+1]}
            if [[ "${var##*.}" == "vcf" ]] && [ -f "$var" ]; then ##Checks if it's VCF and if file exist
                projectDic["inputFile"]+="$var"
                projectDic["inputLoc"]+="${var%/*}"
                local filename=${var%.*} ##removes files extension
                filename=${filename##*/} ##removes file path
                projectDic["filename"]+="$filename"
                frontgate=1
            else
                echo -e "\nERROR. Incorrect file input. Check file or directory path. (Input (.vcf) only)\nEXITING...\n"
                exit 1
            fi
        elif [[ "${i,,}" == "-o" ]]; then ##output location info
            local var=${args[${indexPos}+1]}
            if [ -d "$var" ]; then ##Checks if directory exist, if not it will save to input file location
                if [[ "${var: -1}" == "/" ]]; then
                    projectDic["outputLoc"]+="$var"
                else
                    projectDic["outputLoc"]+="$var"/
                fi
                frontgate=1
            fi
        elif [[ "${i,,}" == "-p" ]]; then ##Project name
            local var=${args[${indexPos}+1]}
            projectDic["projectName"]="$var"
            frontgate=1
        elif [[ "${i,,}" == "-f" ]]; then ##Flank sizes for mutation motif's aln_to_counts func
            local var=${args[${indexPos}+1]}
            frontgate=1
            if [[ "$var" =~ ^[0-2]+$ ]]; then ##Checks if it's a number and if it's between 0 and 2
                ((projectDic["flanks"]+="$var"))
            else
                echo -e "\nFlanks have to be between: 0 - 2. Defaulting to 0.\n"
            fi
        elif [[ "${i,,}" == "-r" ]]; then ##Which reference genome needed for FASTA file creation
            local var=${args[${indexPos}+1]}
            referenceAssignment ${var}
            frontgate=1
        elif [[ "${i}" == "-JOB" ]]; then
            local var=${args[${indexPos}+1]}
            projectDic["JOB"]="${var}"
        elif [[ "${i,,}" == "-n"  ]]; then
            local var=${args[${indexPos}+1]}
            # if [[ "$var" =~ ^[0-9]+$ ]]; then ##CHECK WITH PETER!!!
            #     if (( "${var}" >= 25  && "$var" <= 100 )); then
            #         ((projectDic["nMax"]+="$var"))
            #     elif (( "${var}" < 25 )); then
            #         echo -e "\nMinimum N threshold is 25. Defaulting to 25% threshold."
            #         ((projectDic["nMax"]+=25))
            #     elif (( "${var}" > 100 )); then
            #         echo -e "\nMaximum N threshold is 100. Defaulting to 100% threshold."
            #         ((projectDic["nMax"]+=100))
            #     fi
            #     frontgate=1                    
            # fi
            if [[ "$var" =~ ^[0-9]+$ ]]; then
                if (( "${var}" >= 0  && "$var" <= 100 )); then
                    ((projectDic["nMax"]+="$var"))
                elif (( "${var}" < 0 )); then
                    echo -e "\nMinimum N threshold is 1. Defaulting to 1% threshold."
                    ((projectDic["nMax"]+=1))
                elif (( "${var}" > 100 )); then
                    echo -e "\nMaximum N threshold is 75. Defaulting to 100% threshold."
                    ((projectDic["nMax"]+=100))
                fi
                frontgate=1                    
            fi
        elif [[ "${i,,}" == "-ad"  ]]; then
            local var=${args[${indexPos}+1]}
            projectDic["allData"]="${var,,}"
            frontgate=1
        fi
        ((indexPos+=1))
    done
    if ((${frontgate} <= 0)); then
        echo -e "\nPlease enter valid arguments. None were valid.\n"
    fi
    if [[ ${projectDic["inputFile"]} == '' ]]; then
        echo -e "\nNo input file or working directory specified.\nEXITING...\n"
        exit 1
    fi
    if [[ -z ${projectDic["outputLoc"]} ]] && [[ ${projectDic["inputFile"]} != '' ]]; then
        echo -e "\nNot a valid output location. Re-routing to input file location.\n"
        projectDic["outputLoc"]+=${projectDic["inputLoc"]}
    fi
    if [[ ${projectDic["referenceGenome"]} == "" ]]; then
        referenceAssignment ##Function call
    fi
    if (( ${projectDic["flanks"]} > ${projectDic["windowLength"]} )); then
        # ((projectDic["nMax"]+=25))
        ${projectDic["windowLength"]}=${projectDic["flanks"]}
    fi
}

### REMOVED
#     Current reference genomes for barley and soybean are hard coded here. For other species or reference updates,
#     this will need to be changed.
referenceAssignment(){
    echo -e "\nMUSATFAR, ${1}\n"
    # if [[ ${var,,} == "barley" ]] || [[ ${var,,} == "b" ]]; then ##forced lowercase with ,,
    if [[ ${1,,} == "barley" ]] || [[ ${1,,} == "b" ]]; then ##forced lowercase with ,,
        projectDic["referenceGenomeChar"]+='b'
        projectDic["referenceGenome"]+='/panfs/roc/groups/9/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
    elif [[ ${1,,} == "soybean" ]] || [[ ${1,,} == "s" ]] || [[ ${1,,} == "soy" ]]; then
        projectDic["referenceGenomeChar"]+='s'
        # projectDic["referenceGenome"]+='/panfs/roc/groups/9/morrellp/shared/References/Reference_Sequences/Soybean/PhytozomeV11/Gmax/assembly/Gmax_275_v2.0.fa'
        projectDic["referenceGenome"]+='/panfs/roc/groups/9/morrellp/shared/References/Reference_Sequences/Soybean/Wm82_V1/Gmax_189.fa'
    else
        # echo -e "\nPlease enter a valid reference genome. Defaulting to Barley reference.\n"
        # projectDic["referenceGenomeChar"]+='b'
        # projectDic["referenceGenome"]+='/panfs/roc/groups/9/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
        referenceChecker "${1}"
        projectDic["referenceGenomeChar"]+=${1}
    fi
}

#    Loading modules on UMN MSI system. Three of the four are maintained by Morrell Lab (Corey Carter).
#    Will need to be changed for use outside UMN/MSI
moduleLoader(){ #load modules need for operations

    module load python3_ML/3.6.4
    module load bedops_ML/2.4.20
    module load bedtools_ML/2.23.0

}

#    Performing vcf to bed conversion using bedops 'vcf2bed' function
fileConverter(){
    if [ "${projectDic[OperationalStage]}" == "vcfTObed" ]; then ##Key and new input LOCATION
        local temp="${projectDic["tempOut"]}"SPLITVCF/
        local splitDir=("${temp}"*_split_"${projectDic[filename]}".vcf*)
        for gene in "${splitDir[@]}"; do
            local targetVCF="${gene%.*}"
            targetVCF="${targetVCF##*/}"
            vcf2bed < "${gene}" > "${projectDic["tempOut"]}"BED_SPLIT/"${targetVCF}".bed & ##sort later
        done
        wait
        projectDic[OperationalStage]="bedTOfasta"
    #    Takes a reference genome and bed file and generates small fasta files from reference genome intervals
    elif [ "${projectDic[OperationalStage]}" == "bedTOfasta" ]; then
        local temp="${projectDic["tempOut"]}"BED_SPLIT/
        local splitDir=("${temp}"*"${projectDic[filename]}"_new_interval.bed*)
        for gene in "${splitDir[@]}"; do
            local targetBED="${gene%.*}"
            targetBED="${targetBED##*/}"
            targetBED=${targetBED:0:4}
            bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${gene}" -fo "${projectDic["tempOut"]}"FASTA_SPLIT/"${targetBED}"_"${projectDic[filename]}".fasta &
        done
        wait
        projectDic[OperationalStage]="alnToCounts"
    elif [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
        local temp="${projectDic["tempOut"]}"FASTA_SPLIT/
        local splitDir=("${temp}"*_"${projectDic[filename]}".fasta*)
        echo -e "creating counts tables..."
        for gene in "${splitDir[@]}"; do
            local countfile="${gene%.*}"
            countfile="${countfile##*/}"
            local geneDirection=${countfile:0:4}
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/LOGS
            for loopGene in "${dirL[@]}"; do
                aln_to_counts --align_path "${gene}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/ --flank_size "${projectDic[flanks]}" --direction "${loopGene}" -F > /dev/null
                mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/"${countfile}".txt "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/"${loopGene}"_"${geneDirection^^}"_"${projectDic[filename]}".txt
                mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/LOGS/"${loopGene}"_"${geneDirection^^}"_"${projectDic[filename]}".log ##FIX Unique Log ID'S            
            done
            active+=("${geneDirection}")
        done
        projectDic["OperationalStage"]="allCounts"
    elif [ "${projectDic[OperationalStage]}" == "allCounts" ]; then
        echo -e "creating combined tables..."
        mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/COMBINED_COUNTS
        for loopGene in "${active[@]}"; do
            cd "${projectDic[outputLoc]}"COUNTS_TABLES/"${loopGene}"/
            all_counts -c "*.txt*" -o "${projectDic[outputLoc]}"COUNTS_TABLES/"${loopGene}"/ --strand_symmetric > /dev/null 
            mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${loopGene}"/combined_counts.txt "${projectDic[outputLoc]}"COUNTS_TABLES/COMBINED_COUNTS/"${loopGene}"_combined_counts.txt
        done
        projectDic["OperationalStage"]="DONE..."
    fi

}

#    Creates output directories
dirStructure(){
    DATE=`date +"%m%d%Y-%H%M"`
    mkdir "${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
    projectDic["outputLoc"]="${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
    mkdir "${projectDic[outputLoc]}"COUNTS_TABLES
    if [[ ${projectDic["allData"]} == "true" ]]; then
        mkdir "${projectDic[outputLoc]}"SPLITVCF
        mkdir "${projectDic[outputLoc]}"FASTA_SPLIT
        mkdir "${projectDic[outputLoc]}"BED_SPLIT
        projectDic["tempOut"]="${projectDic[outputLoc]}"
    elif [[ ${projectDic["allData"]} == "false" ]]; then
        projectDic["TempLoc"]+=$(mktemp -d)
        mkdir "${projectDic[TempLoc]}"/SPLITVCF
        mkdir "${projectDic[TempLoc]}"/FASTA_SPLIT
        mkdir "${projectDic[TempLoc]}"/BED_SPLIT
        projectDic["tempOut"]="${projectDic["TempLoc"]}"/
    fi
}

s3Saver(){
    s3cmd mb s3://${projectDic["projectName"],,} > /dev/null
    echo -e "\nS3 bucket created..."
    echo -e "\ntransfering files..."
    if $(( s3cmd put --recursive "${projectDic[outputLoc]}"COUNTS_TABLES/ s3://${projectDic["projectName"],,} > /dev/null )); then
        echo -e "\n Files transfered...\n"
    else
        echo -e "File transfer failed...\n"
    fi
    # local s3Base=$(s3info keys --machine-output) 
#     s3Base="${s3Base}" procDir="${projectDic["tempOut"]}" projectName="${projectDic["projectName"],,}" python3.6 - <<S3_save

# import boto
# from boto.s3.connection import S3Connection
# from boto.s3.key import Key
# import os

# def s3_access_secret(s3Base):
#     access=''
#     secret=''
#     stage=0
#     for i in s3Base:
#         if(i == ' '):
#             stage+=1
#         if(i != '\n') and (stage == 0):
#             access+=i
#         if(i != '\n') and (stage == 1):
#             secret+=i
#     return(access, secret)
    
# def s3_save(project, procDir, access, secret):
#     # geneDir = ['AtoC', 'AtoG', 'AtoT', 'CtoA', 'CtoG', 'CtoT', 'GtoA', 'GtoC', 'GtoT', 'TtoA', 'TtoC','TtoG']
#     # geneDir2 = ['AtoC']
#     # TierTwoConn = S3Connection(access, secret, host='s3.msi.umn.edu')
#     TierTwoConn = boto.connect_s3(access, secret, host='s3.msi.umn.edu')
#     # newBucket = TierTwoConn.create_bucket(project)
#     TierTwoConn.create_bucket(project)
#     # with open(procDir + "/COUNTS_TABLES", 'r')
#     loc = procDir + "/COUNTS_TABLES"
#     file = open(loc)
#     bucketKey = Key(newBucket)
#     bucketKey.key = project
#     result = bucketKey.set_contents_from_file(file)
#     # for u in geneDir2:
#     #     for t in geneDir:


# def bashInputs():
#     s3Base=str(os.environ['s3Base'])
#     project=str(os.environ['projectName'])
#     procDir=str(os.environ['procDir'])
#     return(s3Base, project, procDir)

# def main():
#     s3Base, project, procDir = bashInputs()
#     access, secret = s3_access_secret(s3Base)
#     s3_save(project, procDir, access, secret)

# main()

# S3_save
}

referenceChecker(){
    homeRef=$HOME/".reference_config.csv"
    if [[ -e "${homeRef}" ]]; then ##If there search
        if grep "${var}" ${homeRef} > /dev/null; then ## Checks if var is in file
            export refID=${var}
            projectDic["referenceGenome"]+=$(python3.6 - <<REF_END

import os
import csv
import sys

def referenceScanner(ref):
    baseDir = os.environ["HOME"]
    with open(baseDir + "/" + ".reference_config.csv", newline='') as refScan:
        refDic = csv.DictReader(refScan, delimiter=";")
        for row in refDic:
            if(row["Reference_Name"] == ref):      
                return(row.get("Path"))
    
def bashInputs():
    ref=str(os.environ['refID'])
    return(ref)

def main():
    ref = bashInputs()
    refPath = referenceScanner(ref)
    print(refPath)

main()

REF_END
)
        else ##make this its own IF statement
            export refID=${var}        
            echo -e "\nReference not found, please enter full path: "
            read newRefPath
            ## ADD A IF STATEMENT TO CHECK IF VALID
            # if [[ -d  ]]
            projectDic["referenceGenome"]+="${newRefPath}"
            projectDic["referenceGenomeChar"]+="${var}"
            export newRefPath
            python3.6 - <<REF_END

import os
import csv
import sys

def newRef(ref, path):      
    baseDir = os.environ["HOME"] 
    with open(baseDir + "/" + ".reference_config.csv", 'a+', newline='') as refScan:
        written = csv.writer(refScan, delimiter=";")
        written.writerow([ref,path])

def bashInputs():
    ref=str(os.environ['refID'])
    path=str(os.environ['newRefPath'])
    return(ref, path)

def main():
    ref, path = bashInputs()
    newRef(ref, path)

main()

REF_END
        echo -e "\nPath added and loaded.."
        fi
    else ##If not then create .ref file
        export refID=${var}        
        echo -e "\nReference not found, please enter full path: "
        read newRefPath
        if [[ ! -f newRefPath ]]; then
            echo -e "\nPlease try again and enter a valid path...\n"
            # echo -e "Would you like to try again?"
            # read choice
            ## Finish this IF statement
            exit 1
        fi
        projectDic["referenceGenome"]+="${newRefPath}"
        projectDic["referenceGenomeChar"]+="${var}"
        export newRefPath
        python3.6 - <<REF_END

import os
import csv
import sys

def absNew(ref, path):
    baseDir = os.environ["HOME"]    
    with open(baseDir + "/" + ".reference_config.csv", "a+", newline='') as newRef:
        written = csv.writer(newRef, delimiter=";")     
        written.writerow(["Reference_Name", "Path"])
        written.writerow([ref,path])
    return(0)

def bashInputs():
    ref=str(os.environ['refID'])
    path=str(os.environ['newRefPath'])
    return(ref, path)

def main():
    ref, path = bashInputs()
    absNew(ref, path)

main()

REF_END
        echo -e "\nReference file created and path loaded..."
    fi
}

#    This is Python 3 code embedded in the bash script
#    Expands coverage windows based on user-specified intervals
#    Also checks for "Type One" and "Type Two" overlaps
#    A "Type One overlap" is another SNP within immediate contextual sequence
#    A "Type Two overlap" is another SNP within the expanded flanking contextual sequencing
pythonBEDScanner(){
    inputFile="${projectDic["inputFile"]}" baseOut="${projectDic["outputLoc"]}" outputLoc="${projectDic["tempOut"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" interval="${projectDic["windowLength"]}" geneDir="$geneDir" python3.6 - <<END_OF_PYTHON
    
import os
import re
import subprocess
from itertools import chain
import datetime

def bedMapper(interval, outputLoc, projectName, filename, geneDir):
    output = str(subprocess.check_output(['wc', '-m', outputLoc + "BED_SPLIT/" + geneDir + "_split_" + filename + ".bed"]))
    length = re.findall(r'\d+', output)
    length = int(length[0])
    bedMapper=bytearray()
    masterList=[]
    sub=[] ##FOR BEDMAPPER
    temp=[] ##FOR MASTERLIST
    final=''
    with open(outputLoc + "BED_SPLIT/" + geneDir + "_split_" + filename + ".bed", "rb") as bed_test: ##Change to input variables
        for i in range(length):
            element = bed_test.read(1).decode("ascii")
            if((element != '\t') and (element != '\n')):
                final = final + element
            elif((element == '\t') and (element != '\n')):
                sub.append(final)
                final=''
                sub.append(element)
            if(element == "\n"):
                sub.append(final)
                sub.append(element)
                sub[2] = str(int(sub[2]) - interval)
                sub[4] = str(int(sub[4]) + interval)         
                a = sub[2]
                b = sub[4]
                temp.append(int(a))
                temp.append(int(b))
                temp.sort()
                bedMapper.extend(''.join(sub).encode("utf-8"))
                masterList.append(temp)
                final=''
                sub=[] ## was sub=[]
                temp=[] ## was sub=[]
        with open(outputLoc + "BED_SPLIT/" + geneDir + "_" + filename + "_new_interval.bed", "wb") as newBed: ##Change to input variables
            newBed.write(bedMapper)
        return(masterList)

def binaryIntersect(expandedList, interval, outputLoc, projectName, filename, geneDir, baseOut):
    gateA=True
    gateB=True
    now = datetime.datetime.now()
    results = '\n**********************\nTYPE ONE and TYPE TWO CHECKS FOR: ' + geneDir + " ON " + now.strftime("%Y-%m-%d, %H:%M") + '\n----------------------------------------------------\n' ##ADD PROJECT NAME TO THIS
    resultsA = '\n**' + geneDir + ' TYPE ONE: OVERLAPS INTO ORIGINAL SNPs**\n------------------------------------\n'
    resultsB = '\n**' + geneDir + ' TYPE TWO: OVERLAPS INTO SNP EXPANSION WINDOWS**\n-------------------------------------\n'
    for i in range(len(expandedList)-1): #Checks for Type One SNP overlaps (ORIGINAL INTERVAL CHECK)
            a=expandedList[i][0] ##A= left side
            b=expandedList[i][1] ##B= right side
            subTA=expandedList[i+1][0]-(interval) ##TYPE ONE SWITCHED FROM - TO +
            subTB=expandedList[i+1][1]+(interval) ##TYPE ONE SWITCHED FROM - TO +
            subMA=expandedList[i+1][0] ##TYPE TWO
            subMB=expandedList[i+1][1] ##TYPE TWO
            binary=[0,0,0,0]
            binaryMB=[0,0,0,0]
            if(a <= subTA):
                binary[0]=1
            if(a <= subTB):
                binary[1]=1
            if(b >= subTA):
                binary[2]=1
            if(b >= subTB):
                binary[3]=1
            if(a <= subMA): ##
                binaryMB[0]=1
            if(a <= subMB):
                binaryMB[1]=1
            if(b >= subMA):
                binaryMB[2]=1
            if(b >= subMB):
                binaryMB[3]=1
            if((binary != [1,1,0,0]) and (binary != [0,0,1,1])):
                gateA=False
                if(binary == [0,1,1,0]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subTA) + "-" + str(subTB) + '.'
                elif(binary == [1,1,1,1]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subTA) + "-" + str(subTB) + '.'
                elif((binary == [1,1,1,0]) or (binary == [0,1,1,1])):
                    if(binary == [1,1,1,0]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the right, between " + str(b) + " and " + str(subTA) + '.'
                    elif(binary == [0,1,1,1]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the left, between " + str(a) + " and " + str(subTB) + '.' 
            if((binaryMB != [1,1,0,0]) and (binaryMB != [0,0,1,1])):
                gateB=False
                if(binaryMB == [0,1,1,0]):
                    resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subMA) + "-" + str(subMB) + '.'
                elif(binaryMB == [1,1,1,1]):
                    resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subMA) + "-" + str(subMB) + '.'
                elif((binaryMB == [1,1,1,0]) or (binaryMB == [0,1,1,1])):
                    if(binaryMB == [1,1,1,0]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the right, between " + str(b) + " and " + str(subMA) + '.'
                    elif(binaryMB == [0,1,1,1]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the left, between " + str(a) + " and " + str(subMB) + '.' 
    if(gateA):
        resultsA+="\nNo Type ONE window overlaps detected.\n"
    if(gateB):
        resultsB+="\nNo Type TWO window overlaps detected.\n"
    results += resultsA + "\n" + resultsB + "\n"
    results += "\nEND OF INTERVAL CHECKS.\nXXXXXXXXXXXXXXXXXXXXXX\n"
    with open(baseOut + projectName + "_" + "WindowOverlap.txt", 'a+') as window:
        window.write(results)
        
def bashInputs():
    outputLoc=str(os.environ['outputLoc'])
    filename=str(os.environ['filename'])
    interval=int(os.environ['interval'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    geneDir=str(os.environ['geneDir'])
    baseOut=str(os.environ['baseOut'])
    return(outputLoc, filename, interval, inputFile, projectName, geneDir, baseOut)

def main():
    outputLoc, filename, interval, inputFile, projectName, geneDir, baseOut=bashInputs()
    masterList=bedMapper(interval, outputLoc, projectName, filename, geneDir) 
    binaryIntersect(masterList, interval, outputLoc, projectName, filename, geneDir, baseOut)
main()

END_OF_PYTHON

}

jobCreator(){
    echo -e "Enter email for PBS job updates: "
    read userEmail
    email="${userEmail}" nMax="${projectDic["nMax"]}" allData="${projectDic["allData"]}" inputFile="${projectDic["inputFile"]}" outputLoc="${projectDic["outputLoc"]}" projectName="${projectDic["projectName"]}" windowLength="${projectDic["windowLength"]}" flanks="${projectDic["flanks"]}" referenceGenome="${projectDic["referenceGenomeChar"]}" python3.6 - <<JOB_CREATED

import os

def jobScript(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax):
    job="#!/bin/bash -l\n\n#PBS -l walltime=24:00:00,nodes=2:ppn=10,mem=20gb\n#PBS -m abe\n#PBS -M " + email + "\n"
    job+="#PBS -N " + projectName + "_" + "SNP-Context" + "\n#PBS -q small\nset -e\nset -o pipefail\n\n"
    job+="#PBS -o " + outputLoc + "_" + projectName + "\n#PBS -e " + outputLoc + "_" + projectName + "\n"
    job+="\nmodule load snpContext/1.0.0\n\n"
    # job+="snpcontext "
    job+="/panfs/roc/groups/9/morrellp/public/Software/SNP_Context/SNPcontext "
    job+= "-i " + inputFile + " "
    job+= "-o " + outputLoc + " "
    job+= "-w " + windowLength + " "
    job+= "-f " + flanks + " "
    job+= "-p " + projectName + " "
    job+= "-r " + referenceGenome + " "
    job+= "-ad " + allData + " "
    job+= "-n " + nMax + " "
    job+= "-JOB THIS_IS_A_JOB"

    with open(outputLoc + projectName + ".job", "w") as jobScript:
        jobScript.write(job)

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    email=str(os.environ['email'])
    flanks=str(os.environ['flanks'])
    referenceGenome=str(os.environ['referenceGenome'])
    windowLength=str(os.environ['windowLength'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    allData=str(os.environ['allData'])
    nMax=str(os.environ['nMax'])
    return(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax)

def main():
    projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax = bashImport()
    jobScript(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax)

main()
    
JOB_CREATED

qsub "${projectDic["outputLoc"]}""${projectDic["projectName"]}".job
echo -e "\njob submited.\nEXITING...\n"
exit 0

}

vcfSplit(){
    inputFile="${projectDic["inputFile"]}" baseOut="${projectDic["outputLoc"]}" outputLoc="${projectDic["tempOut"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" python3.6 - <<VCF_SPLIT_END

import os

def geneDirCreate():
    geneDir={

        'AtoC':bytearray(),
        'AtoG':bytearray(),
        'AtoT':bytearray(),
        'CtoA':bytearray(),
        'CtoG':bytearray(),
        'CtoT':bytearray(),
        'GtoA':bytearray(),
        'GtoC':bytearray(),
        'GtoT':bytearray(),
        'TtoA':bytearray(),
        'TtoC':bytearray(),
        'TtoG':bytearray(),
        'rejected':bytearray(),
        'header':bytearray(),
        
    }
    return(geneDir)

def vcfSegments(inputFile, geneDir):
    with open(inputFile, "rb") as raw:
        sub=[]
        counter=0
        gene=''
        results=''
        for readLine in raw:
            sub.clear()
            gene=''
            results=''
            gate=True
            counter=0
            while((gate == True) and (counter <= len(readLine))):
                element = chr(readLine[counter])
                if((element != '#') or (chr(readLine[0]) != "#")):                                
                    if((element != '\t') and (element != '\n')):
                        results = results + element
                    elif((element == '\t') and (element != '\n')):
                        sub.append(results)
                        sub.append(element)
                        results=''
                    if((element == "\n") or (len(sub) == 9)):
                        gene= str(sub[6]) + "to" + str(sub[8])
                        if gene in geneDir:
                            geneDir[gene].extend(readLine)
                            sub.clear()
                            gate=False
                        else:
                            geneDir['rejected'].extend(readLine)
                            sub.clear()
                            gate=False
                else:
                    geneDir['header'].extend(readLine)
                    gate=False
                counter+=1
    return(geneDir)

def vcfSpliter(geneDir, outputLoc, filename, baseOut):
    for key in geneDir:
        if(geneDir[key]):
            if((key != "rejected") and (key != "header")):
                with open(outputLoc + "SPLITVCF/" + key + "_split_" + filename + ".vcf","ab") as vcfOut:
                    vcfOut.write(geneDir['header'])
                    vcfOut.write(geneDir[key])
            else:
                if(key != "header"):
                    with open(baseOut + "REJECTEDVCFs_" + filename + ".vcf","ab") as vcfOut:
                        vcfOut.write(geneDir['header'])
                        vcfOut.write(geneDir[key])

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    inputFile=str(os.environ['inputFile'])
    filename=str(os.environ['filename'])
    projectName=str(os.environ['projectName'])
    baseOut=str(os.environ['baseOut'])
    return(projectName, inputFile, outputLoc, filename, baseOut)

def main():
    projectName, inputFile, outputLoc, filename, baseOut=bashImport()
    geneDir=geneDirCreate()
    geneDir=vcfSegments(inputFile, geneDir)
    vcfSpliter(geneDir, outputLoc, filename, baseOut)

main()

VCF_SPLIT_END

}

fastaScanner(){

    inputFile="${projectDic["inputFile"]}" flank="${projectDic["flanks"]}" baseOut="${projectDic["outputLoc"]}" outputLoc="${projectDic["tempOut"]}" filename="${projectDic["filename"]}" geneTwo=${geneTwo} geneDirTwo="${geneDirTwo}" nMax="${projectDic["nMax"]}" windowLength="${projectDic["windowLength"]}" python3.6 - <<FASTA_SWEEP
    
from itertools import chain
import os

def fastaMapper(gene):
    with open(gene ,"rb") as fasta:
        fastafile=fasta.read()
        totalN=0
        master=[]
        sub=[]
        final=''
        for counter, i in enumerate(fastafile):
            element=chr(i)
            if(element == 'N'):
                totalN+=1
            if((element != "\n") and (element != ">")):
                final = final + str(element)
            if((element == "\n") and (element != ">")):
                final = final + str(element)
                sub.append(final)
                final=''
            if((element == ">") and (element != "\n")):
                if(sub != []):
                    if(sub[0] != ">"):
                        sub = [u.upper() for u in sub]
                    master.append(sub)
                    sub=[]
                    final=''
                    final = final + str(element)
                else:
                    final = final + str(element)
            if(counter == (len(fastafile)-1)):
                final = final + str(element)
                sub.append(final)
                master.append(sub)
    return(master)

def fastaNpop(subMaster, allRejected, nMax):
    maxP=nMax/100
    newsubMaster=[]
    nMaxList=[]
    for subListing in subMaster:
        totalN = len([x for x in subListing[1] if x == "N"])
        nPercent=totalN/len(subListing[1])
        if(nPercent >= maxP):
            nMaxList.append(subListing)
        else:
            newsubMaster.append(subListing)
    return(newsubMaster, nMaxList)

def fastaBasePop(master, interval, flank):
    allRejected=False
    subMaster=[]
    nList=[]
    if(interval > 2):
        Linterval=interval - flank ##change to 4
        Rinterval=interval - (flank - 1) ##change to 4
    else:
        Linterval=0 ##change to 4
        Rinterval=-1 ##change to 4
    for element in master: ##CHANGE TO SUBTRACT CORRECT DISTANCES
        baseIn = element[1][(Linterval):-(Rinterval)] ##MAYBE add +1 on Rinterval.
        if("N" not in baseIn):
            subMaster.append(element)
        else:
            nList.append(element)
    if(len(subMaster) == 0):
        allRejected=True
    return(subMaster, allRejected, nList)

def fileSaver(subMaster, master, nList, nMaxList, gene, allRejected, baseOut, filename, geneDirTwo, outputLoc):
    if(allRejected != True):
        with open(gene,"w") as newFasta:
            output="".join(chain.from_iterable(subMaster))
            newFasta.write(output)
    else:
        with open(baseOut + "FASTA_SPLIT/" + geneDirTwo + filename + ".fasta","w") as newFasta:
            output="".join(chain.from_iterable(master))
            newFasta.write(output)
        os.rename(outputLoc + "FASTA_SPLIT/" + geneDirTwo + filename + ".fasta", outputLoc + "ALLREJECTED_" + geneDirTwo + "_" + filename + ".fasta")
    if(len(nList) != 0):
        with open(baseOut + "N-BASE_FAILED_FASTAS.fasta","a") as newFasta:
            output="".join(chain.from_iterable(nList))
            newFasta.write(output)
    if(len(nMaxList) != 0):
        with open(baseOut + "N-THRESHOLD_FAILED_FASTAS.fasta","a") as newFasta:
            output="".join(chain.from_iterable(nMaxList))
            newFasta.write(output)

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    flank=int(os.environ['flank'])
    filename=str(os.environ['filename'])
    gene=str(os.environ['geneTwo'])
    nMax=int(os.environ['nMax'])
    geneDirTwo=str(os.environ['geneDirTwo']) ##GENE Direction
    interval=int(os.environ['windowLength'])
    baseOut=str(os.environ['baseOut'])
    return(flank, outputLoc, filename, gene, geneDirTwo, interval, nMax, baseOut)

def main():
    flank, outputLoc, filename, gene, geneDirTwo, interval, nMax, baseOut = bashImport()
    master=fastaMapper(gene)
    subMaster, allRejected, nList = fastaBasePop(master, interval, flank)
    subMaster, nMaxList = fastaNpop(subMaster, allRejected, nMax)
    fileSaver(subMaster, master, nList, nMaxList, gene, allRejected, baseOut, filename, geneDirTwo, outputLoc)

main()

FASTA_SWEEP

}

main(){
    moduleLoader ##LOADS CORRECT MODULES    
    ## ADD CHECKER
    # starter "$@" ##ASSIGNS INPUTS TO HASHMAP ##REMOVE
    config_check "$@"
    if [[ "${projectDic["JOB"]}" != "THIS_IS_A_JOB" ]]; then
        inputSize=$( stat -c%s "${projectDic["inputFile"]}")
        if (( "${inputSize}" >= 479000000 )); then ##479MB (in decimal) and 456MB (in binary)
            echo -e "\n(.VCF) over 456Mb, generating job script and submitting operations to MSI."
            jobCreator
        fi
    fi
    dirStructure
    vcfSplit
    fileConverter ##MAKES BED FILE
    local temp="${projectDic["tempOut"]}"BED_SPLIT/
    local splitDir=("${temp}"*_split_"${projectDic[filename]}".bed*)
    for gene in "${splitDir[@]}"; do
        local geneDir="${gene%.*}"
        geneDir="${geneDir##*/}"
        geneDir=${geneDir:0:4} ##BASH IS BASE 1
        pythonBEDScanner "$geneDir" & ##EXPANDS BED FILE WINDOWS AND CHECKS FOR OVER LAP
    done
    wait
    echo -e "\nOverlap checks completed..."
    echo -e "See Overlap results located in 'WindowOverlap.txt' in your main output directory.\n"
    fileConverter ##CREATES FASTA FILE
    local tempTwo="${projectDic["tempOut"]}"FASTA_SPLIT/
    local fastalisting=("${tempTwo}"*_"${projectDic[filename]}".fasta*)
    for geneTwo in "${fastalisting[@]}"; do
        local geneDirTwo="${geneTwo%.*}"
        geneDirTwo="${geneDirTwo##*/}"
        geneDirTwo=${geneDirTwo:0:4}
        fastaScanner "${geneDirTwo}" "${geneTwo}" & ##COPIES MASTER FASTA FILE 12 TIMES FOR ALN_TO_COUNTS
    done
    wait
    fileConverter ##ALN_TO_COUNTS TABLES WHICH ARE FED INTO ALL_COUNTS
    fileConverter ##ALL_COUNTS
    if [[ "${projectDic["allData"]}" == "false"  ]]; then
        local templocation="${projectDic["TempLoc"]}"
        rm -rf "${templocation}"
    fi
    ##Add dropbox intergration
    if [[ "${projectDic["S3"]}" == 'true' ]]; then
        echo -e "\nTEST\n"
        s3Saver
    fi
    echo -e "operations completed...\n"
        
}

main "$@"
